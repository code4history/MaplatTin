(function(ht,zt){typeof exports=="object"&&typeof module<"u"?zt(exports,require("@turf/boolean-point-in-polygon"),require("@turf/centroid"),require("@turf/convex"),require("@turf/helpers"),require("delaunator"),require("@turf/line-intersect")):typeof define=="function"&&define.amd?define(["exports","@turf/boolean-point-in-polygon","@turf/centroid","@turf/convex","@turf/helpers","delaunator","@turf/line-intersect"],zt):(ht=typeof globalThis<"u"?globalThis:ht||self,zt(ht.tin={},ht.turf.booleanPointInPolygon,ht.turf.centroid,ht.turf.convex,ht.turf.helpers,ht.Delaunator,ht.turf.lineIntersect))})(this,(function(ht,zt,rn,Me,at,cn,an){"use strict";var fn=Object.defineProperty,hn=(r,t,n)=>t in r?fn(r,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):r[t]=n,tt=(r,t,n)=>hn(r,typeof t!="symbol"?t+"":t,n);const Et=11102230246251565e-32,dt=134217729,un=(3+8*Et)*Et;function he(r,t,n,e,i){let s,o,c,h,f=t[0],l=e[0],a=0,u=0;l>f==l>-f?(s=f,f=t[++a]):(s=l,l=e[++u]);let d=0;if(a<r&&u<n)for(l>f==l>-f?(o=f+s,c=s-(o-f),f=t[++a]):(o=l+s,c=s-(o-l),l=e[++u]),s=o,c!==0&&(i[d++]=c);a<r&&u<n;)l>f==l>-f?(o=s+f,h=o-s,c=s-(o-h)+(f-h),f=t[++a]):(o=s+l,h=o-s,c=s-(o-h)+(l-h),l=e[++u]),s=o,c!==0&&(i[d++]=c);for(;a<r;)o=s+f,h=o-s,c=s-(o-h)+(f-h),f=t[++a],s=o,c!==0&&(i[d++]=c);for(;u<n;)o=s+l,h=o-s,c=s-(o-h)+(l-h),l=e[++u],s=o,c!==0&&(i[d++]=c);return(s!==0||d===0)&&(i[d++]=s),d}function ln(r,t){let n=t[0];for(let e=1;e<r;e++)n+=t[e];return n}function Xt(r){return new Float64Array(r)}const dn=(3+16*Et)*Et,gn=(2+12*Et)*Et,wn=(9+64*Et)*Et*Et,Lt=Xt(4),Se=Xt(8),ve=Xt(12),Ae=Xt(16),wt=Xt(4);function pn(r,t,n,e,i,s,o){let c,h,f,l,a,u,d,y,w,m,p,S,E,O,R,T,F,q;const L=r-i,st=n-i,it=t-s,z=e-s;O=L*z,u=dt*L,d=u-(u-L),y=L-d,u=dt*z,w=u-(u-z),m=z-w,R=y*m-(O-d*w-y*w-d*m),T=it*st,u=dt*it,d=u-(u-it),y=it-d,u=dt*st,w=u-(u-st),m=st-w,F=y*m-(T-d*w-y*w-d*m),p=R-F,a=R-p,Lt[0]=R-(p+a)+(a-F),S=O+p,a=S-O,E=O-(S-a)+(p-a),p=E-T,a=E-p,Lt[1]=E-(p+a)+(a-T),q=S+p,a=q-S,Lt[2]=S-(q-a)+(p-a),Lt[3]=q;let Z=ln(4,Lt),g=gn*o;if(Z>=g||-Z>=g||(a=r-L,c=r-(L+a)+(a-i),a=n-st,f=n-(st+a)+(a-i),a=t-it,h=t-(it+a)+(a-s),a=e-z,l=e-(z+a)+(a-s),c===0&&h===0&&f===0&&l===0)||(g=wn*o+un*Math.abs(Z),Z+=L*l+z*c-(it*f+st*h),Z>=g||-Z>=g))return Z;O=c*z,u=dt*c,d=u-(u-c),y=c-d,u=dt*z,w=u-(u-z),m=z-w,R=y*m-(O-d*w-y*w-d*m),T=h*st,u=dt*h,d=u-(u-h),y=h-d,u=dt*st,w=u-(u-st),m=st-w,F=y*m-(T-d*w-y*w-d*m),p=R-F,a=R-p,wt[0]=R-(p+a)+(a-F),S=O+p,a=S-O,E=O-(S-a)+(p-a),p=E-T,a=E-p,wt[1]=E-(p+a)+(a-T),q=S+p,a=q-S,wt[2]=S-(q-a)+(p-a),wt[3]=q;const b=he(4,Lt,4,wt,Se);O=L*l,u=dt*L,d=u-(u-L),y=L-d,u=dt*l,w=u-(u-l),m=l-w,R=y*m-(O-d*w-y*w-d*m),T=it*f,u=dt*it,d=u-(u-it),y=it-d,u=dt*f,w=u-(u-f),m=f-w,F=y*m-(T-d*w-y*w-d*m),p=R-F,a=R-p,wt[0]=R-(p+a)+(a-F),S=O+p,a=S-O,E=O-(S-a)+(p-a),p=E-T,a=E-p,wt[1]=E-(p+a)+(a-T),q=S+p,a=q-S,wt[2]=S-(q-a)+(p-a),wt[3]=q;const _=he(b,Se,4,wt,ve);O=c*l,u=dt*c,d=u-(u-c),y=c-d,u=dt*l,w=u-(u-l),m=l-w,R=y*m-(O-d*w-y*w-d*m),T=h*f,u=dt*h,d=u-(u-h),y=h-d,u=dt*f,w=u-(u-f),m=f-w,F=y*m-(T-d*w-y*w-d*m),p=R-F,a=R-p,wt[0]=R-(p+a)+(a-F),S=O+p,a=S-O,E=O-(S-a)+(p-a),p=E-T,a=E-p,wt[1]=E-(p+a)+(a-T),q=S+p,a=q-S,wt[2]=S-(q-a)+(p-a),wt[3]=q;const M=he(_,ve,4,wt,Ae);return Ae[M-1]}function mn(r,t,n,e,i,s){const o=(t-s)*(n-i),c=(r-i)*(e-s),h=o-c,f=Math.abs(o+c);return Math.abs(h)>=dn*f?h:-pn(r,t,n,e,i,s,f)}function bn(r,t){var n,e,i=0,s,o,c,h,f,l,a,u=r[0],d=r[1],y=t.length;for(n=0;n<y;n++){e=0;var w=t[n],m=w.length-1;if(l=w[0],l[0]!==w[m][0]&&l[1]!==w[m][1])throw new Error("First and last coordinates in a ring must be the same");for(o=l[0]-u,c=l[1]-d,e;e<m;e++){if(a=w[e+1],h=a[0]-u,f=a[1]-d,c===0&&f===0){if(h<=0&&o>=0||o<=0&&h>=0)return 0}else if(f>=0&&c<=0||f<=0&&c>=0){if(s=mn(o,h,c,f,0,0),s===0)return 0;(s>0&&f>0&&c<=0||s<0&&f<=0&&c>0)&&i++}l=a,c=f,o=h}}return i%2!==0}function Ee(r,t,n={}){const e={type:"Feature"};return(n.id===0||n.id)&&(e.id=n.id),n.bbox&&(e.bbox=n.bbox),e.properties=t||{},e.geometry=r,e}function Wt(r,t,n={}){if(!r)throw new Error("coordinates is required");if(!Array.isArray(r))throw new Error("coordinates must be an Array");if(r.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!Te(r[0])||!Te(r[1]))throw new Error("coordinates must contain numbers");return Ee({type:"Point",coordinates:r},t,n)}function Oe(r,t,n={}){for(const e of r){if(e.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");if(e[e.length-1].length!==e[0].length)throw new Error("First and last Position are not equivalent.");for(let i=0;i<e[e.length-1].length;i++)if(e[e.length-1][i]!==e[0][i])throw new Error("First and last Position are not equivalent.")}return Ee({type:"Polygon",coordinates:r},t,n)}function Pt(r,t={}){const n={type:"FeatureCollection"};return t.id&&(n.id=t.id),t.bbox&&(n.bbox=t.bbox),n.features=r,n}function Te(r){return!isNaN(r)&&r!==null&&!Array.isArray(r)}function yn(r){if(!r)throw new Error("coord is required");if(!Array.isArray(r)){if(r.type==="Feature"&&r.geometry!==null&&r.geometry.type==="Point")return[...r.geometry.coordinates];if(r.type==="Point")return[...r.coordinates]}if(Array.isArray(r)&&r.length>=2&&!Array.isArray(r[0])&&!Array.isArray(r[1]))return[...r];throw new Error("coord must be GeoJSON Point or an Array of numbers")}function Ie(r){if(Array.isArray(r))return r;if(r.type==="Feature"){if(r.geometry!==null)return r.geometry.coordinates}else if(r.coordinates)return r.coordinates;throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")}function kn(r){return r.type==="Feature"?r.geometry:r}function _n(r,t,n={}){if(!r)throw new Error("point is required");if(!t)throw new Error("polygon is required");const e=yn(r),i=kn(t),s=i.type,o=t.bbox;let c=i.coordinates;if(o&&xn(e,o)===!1)return!1;s==="Polygon"&&(c=[c]);let h=!1;for(var f=0;f<c.length;++f){const l=bn(e,c[f]);if(l===0)return!n.ignoreBoundary;l&&(h=!0)}return h}function xn(r,t){return t[0]<=r[0]&&t[1]<=r[1]&&t[2]>=r[0]&&t[3]>=r[1]}var ue=_n;function Ne(r){const t=r.features;for(let n=0;n<t.length;n++){const e=t[n];`${e.properties.a.index}`.substring(0,1)==="b"&&`${e.properties.b.index}`.substring(0,1)==="b"?t[n]={geometry:{type:"Polygon",coordinates:[[e.geometry.coordinates[0][2],e.geometry.coordinates[0][0],e.geometry.coordinates[0][1],e.geometry.coordinates[0][2]]]},properties:{a:{geom:e.properties.c.geom,index:e.properties.c.index},b:{geom:e.properties.a.geom,index:e.properties.a.index},c:{geom:e.properties.b.geom,index:e.properties.b.index}},type:"Feature"}:`${e.properties.c.index}`.substring(0,1)==="b"&&`${e.properties.a.index}`.substring(0,1)==="b"&&(t[n]={geometry:{type:"Polygon",coordinates:[[e.geometry.coordinates[0][1],e.geometry.coordinates[0][2],e.geometry.coordinates[0][0],e.geometry.coordinates[0][1]]]},properties:{a:{geom:e.properties.b.geom,index:e.properties.b.index},b:{geom:e.properties.c.geom,index:e.properties.c.index},c:{geom:e.properties.a.geom,index:e.properties.a.index}},type:"Feature"})}return r}function Ce(r){const t=["a","b","c","a"].map(s=>r.properties[s].geom),n=r.geometry.coordinates[0],e=r.properties,i={a:{geom:n[0],index:e.a.index},b:{geom:n[1],index:e.b.index},c:{geom:n[2],index:e.c.index}};return Oe([t],i)}function Mn(r){const t=[0,1,2,0].map(e=>r[e][0][0]),n={a:{geom:r[0][0][1],index:r[0][1]},b:{geom:r[1][0][1],index:r[1][1]},c:{geom:r[2][0][1],index:r[2][1]}};return Oe([t],n)}function Zt(r,t,n,e,i,s=!1,o){const c=r.map(h=>{(!o||o<2.00703)&&(h=Re(h));const f=isFinite(h)?t[h]:h==="c"?e:h==="b0"?i[0]:h==="b1"?i[1]:h==="b2"?i[2]:h==="b3"?i[3]:(function(){const l=h.match(/e(\d+)/);if(l){const a=parseInt(l[1]);return n[a]}throw"Bad index value for indexesToTri"})();return s?[[f[1],f[0]],h]:[[f[0],f[1]],h]});return Mn(c)}function Re(r){return typeof r=="number"?r:r.replace(/^(c|e|b)(?:ent|dgeNode|box)(\d+)?$/,"$1$2")}function Be(r,t){return t&&t>=2.00703||Array.isArray(r[0])?r:r.map(n=>[n.illstNodes,n.mercNodes,n.startEnd])}function je(r,t){for(let n=0;n<t.features.length;n++)if(ue(r,t.features[n]))return t.features[n]}function Pe(r,t,n){const e=t.geometry.coordinates[0][0],i=t.geometry.coordinates[0][1],s=t.geometry.coordinates[0][2],o=r.geometry.coordinates,c=t.properties.a.geom,h=t.properties.b.geom,f=t.properties.c.geom,l=[i[0]-e[0],i[1]-e[1]],a=[s[0]-e[0],s[1]-e[1]],u=[o[0]-e[0],o[1]-e[1]],d=[h[0]-c[0],h[1]-c[1]],y=[f[0]-c[0],f[1]-c[1]];let w=(a[1]*u[0]-a[0]*u[1])/(l[0]*a[1]-l[1]*a[0]),m=(l[0]*u[1]-l[1]*u[0])/(l[0]*a[1]-l[1]*a[0]);if(n){const p=n[t.properties.a.index],S=n[t.properties.b.index],E=n[t.properties.c.index];let O;if(w<0||m<0||1-w-m<0){const R=w/(w+m),T=m/(w+m);O=w/S/(R/S+T/E),m=m/E/(R/S+T/E)}else O=w/S/(w/S+m/E+(1-w-m)/p),m=m/E/(w/S+m/E+(1-w-m)/p);w=O}return[w*d[0]+m*y[0]+c[0],w*d[1]+m*y[1]+c[1]]}function Sn(r,t,n,e){const i=r.geometry.coordinates,s=n.geometry.coordinates,o=Math.atan2(i[0]-s[0],i[1]-s[1]),c=vn(o,t[0]);if(c===void 0)throw new Error("Unable to determine vertex index");const h=t[1][c];return Pe(r,h.features[0],e)}function te(r,t,n,e,i,s,o,c){let h;if(o&&(h=je(r,Pt([o]))),!h){if(n){const f=r.geometry.coordinates,l=n.gridNum,a=n.xOrigin,u=n.yOrigin,d=n.xUnit,y=n.yUnit,w=n.gridCache,m=Mt(f[0],a,d,l),p=Mt(f[1],u,y,l),S=w[m]?w[m][p]?w[m][p]:[]:[];t=Pt(S.map(E=>t.features[E]))}h=je(r,t)}return c&&c(h),h?Pe(r,h,s):Sn(r,e,i,s)}function Mt(r,t,n,e){let i=Math.floor((r-t)/n);return i>=e&&(i=e-1),i}function vn(r,t){let n=$e(r-t[0]),e=Math.PI*2,i;for(let s=0;s<t.length;s++){const o=(s+1)%t.length,c=$e(r-t[o]),h=Math.min(Math.abs(n),Math.abs(c));n*c<=0&&h<e&&(e=h,i=s),n=c}return i}function $e(r,t=!1){const n=t?function(e){return!(e>=0&&e<Math.PI*2)}:function(e){return!(e>-1*Math.PI&&e<=Math.PI)};for(;n(r);)r=r+2*Math.PI*(r>0?-1:1);return r}const ee=2.00703,_t=class xt{constructor(){tt(this,"points",[]),tt(this,"pointsWeightBuffer"),tt(this,"strict_status"),tt(this,"vertices_params"),tt(this,"centroid"),tt(this,"edgeNodes"),tt(this,"edges"),tt(this,"tins"),tt(this,"kinks"),tt(this,"yaxisMode",xt.YAXIS_INVERT),tt(this,"strictMode",xt.MODE_AUTO),tt(this,"vertexMode",xt.VERTEX_PLAIN),tt(this,"bounds"),tt(this,"boundsPolygon"),tt(this,"wh"),tt(this,"xy"),tt(this,"indexedTins"),tt(this,"stateFull",!1),tt(this,"stateTriangle"),tt(this,"stateBackward")}setCompiled(t){if(t.version||!t.tins&&t.points&&t.tins_points){this.points=t.points,this.pointsWeightBuffer=!t.version||t.version<2.00703?["forw","bakw"].reduce((e,i)=>{const s=t.weight_buffer[i];return s&&(e[i]=Object.keys(s).reduce((o,c)=>{const h=Re(c);return o[h]=s[c],o},{})),e},{}):t.weight_buffer,t.strict_status?this.strict_status=t.strict_status:t.kinks_points?this.strict_status=xt.STATUS_ERROR:t.tins_points.length==2?this.strict_status=xt.STATUS_LOOSE:this.strict_status=xt.STATUS_STRICT,this.vertices_params={forw:[t.vertices_params[0]],bakw:[t.vertices_params[1]]},this.vertices_params.forw[1]=[0,1,2,3].map(e=>{const i=(e+1)%4,s=Zt(["c",`b${e}`,`b${i}`],t.points,t.edgeNodes||[],t.centroid_point,t.vertices_points,!1,ee);return Pt([s])}),this.vertices_params.bakw[1]=[0,1,2,3].map(e=>{const i=(e+1)%4,s=Zt(["c",`b${e}`,`b${i}`],t.points,t.edgeNodes||[],t.centroid_point,t.vertices_points,!0,ee);return Pt([s])}),this.centroid={forw:Wt(t.centroid_point[0],{target:{geom:t.centroid_point[1],index:"c"}}),bakw:Wt(t.centroid_point[1],{target:{geom:t.centroid_point[0],index:"c"}})},this.edges=Be(t.edges||[]),this.edgeNodes=t.edgeNodes||[];const n=t.tins_points.length==1?0:1;this.tins={forw:Pt(t.tins_points[0].map(e=>Zt(e,t.points,t.edgeNodes||[],t.centroid_point,t.vertices_points,!1,t.version))),bakw:Pt(t.tins_points[n].map(e=>Zt(e,t.points,t.edgeNodes||[],t.centroid_point,t.vertices_points,!0,t.version)))},this.addIndexedTin(),t.kinks_points&&(this.kinks={bakw:Pt(t.kinks_points.map(e=>Wt(e)))}),t.yaxisMode?this.yaxisMode=t.yaxisMode:this.yaxisMode=xt.YAXIS_INVERT,t.vertexMode&&(this.vertexMode=t.vertexMode),t.strictMode&&(this.strictMode=t.strictMode),t.bounds?(this.bounds=t.bounds,this.boundsPolygon=t.boundsPolygon,this.xy=t.xy,this.wh=t.wh):(this.xy=[0,0],t.wh&&(this.wh=t.wh),this.bounds=void 0,this.boundsPolygon=void 0)}else{t=JSON.parse(JSON.stringify(t).replace('"cent"','"c"').replace(/"bbox(\d+)"/g,'"b$1"')),this.tins=t.tins,this.addIndexedTin(),this.strict_status=t.strict_status,this.pointsWeightBuffer=t.weight_buffer,this.vertices_params=t.vertices_params,this.centroid=t.centroid,this.kinks=t.kinks;const n=[];for(let e=0;e<this.tins.forw.features.length;e++){const i=this.tins.forw.features[e];["a","b","c"].map((s,o)=>{const c=i.geometry.coordinates[0][o],h=i.properties[s].geom,f=i.properties[s].index;typeof f=="number"&&(n[f]=[c,h])})}this.points=n}}addIndexedTin(){const t=this.tins,n=t.forw,e=t.bakw,i=Math.ceil(Math.sqrt(n.features.length));if(i<3){this.indexedTins=void 0;return}let s=[],o=[];const c=n.features.map(w=>{let m=[];return Ie(w)[0].map(p=>{s.length===0?s=[Array.from(p),Array.from(p)]:(p[0]<s[0][0]&&(s[0][0]=p[0]),p[0]>s[1][0]&&(s[1][0]=p[0]),p[1]<s[0][1]&&(s[0][1]=p[1]),p[1]>s[1][1]&&(s[1][1]=p[1])),m.length===0?m=[Array.from(p),Array.from(p)]:(p[0]<m[0][0]&&(m[0][0]=p[0]),p[0]>m[1][0]&&(m[1][0]=p[0]),p[1]<m[0][1]&&(m[0][1]=p[1]),p[1]>m[1][1]&&(m[1][1]=p[1]))}),m}),h=(s[1][0]-s[0][0])/i,f=(s[1][1]-s[0][1])/i,l=c.reduce((w,m,p)=>{const S=Mt(m[0][0],s[0][0],h,i),E=Mt(m[1][0],s[0][0],h,i),O=Mt(m[0][1],s[0][1],f,i),R=Mt(m[1][1],s[0][1],f,i);for(let T=S;T<=E;T++){w[T]||(w[T]=[]);for(let F=O;F<=R;F++)w[T][F]||(w[T][F]=[]),w[T][F].push(p)}return w},[]),a=e.features.map(w=>{let m=[];return Ie(w)[0].map(p=>{o.length===0?o=[Array.from(p),Array.from(p)]:(p[0]<o[0][0]&&(o[0][0]=p[0]),p[0]>o[1][0]&&(o[1][0]=p[0]),p[1]<o[0][1]&&(o[0][1]=p[1]),p[1]>o[1][1]&&(o[1][1]=p[1])),m.length===0?m=[Array.from(p),Array.from(p)]:(p[0]<m[0][0]&&(m[0][0]=p[0]),p[0]>m[1][0]&&(m[1][0]=p[0]),p[1]<m[0][1]&&(m[0][1]=p[1]),p[1]>m[1][1]&&(m[1][1]=p[1]))}),m}),u=(o[1][0]-o[0][0])/i,d=(o[1][1]-o[0][1])/i,y=a.reduce((w,m,p)=>{const S=Mt(m[0][0],o[0][0],u,i),E=Mt(m[1][0],o[0][0],u,i),O=Mt(m[0][1],o[0][1],d,i),R=Mt(m[1][1],o[0][1],d,i);for(let T=S;T<=E;T++){w[T]||(w[T]=[]);for(let F=O;F<=R;F++)w[T][F]||(w[T][F]=[]),w[T][F].push(p)}return w},[]);this.indexedTins={forw:{gridNum:i,xOrigin:s[0][0],yOrigin:s[0][1],xUnit:h,yUnit:f,gridCache:l},bakw:{gridNum:i,xOrigin:o[0][0],yOrigin:o[0][1],xUnit:u,yUnit:d,gridCache:y}}}transform(t,n,e){if(n&&this.strict_status==xt.STATUS_ERROR)throw'Backward transform is not allowed if strict_status == "strict_error"';this.yaxisMode==xt.YAXIS_FOLLOW&&n&&(t=[t[0],-1*t[1]]);const i=Wt(t);if(this.bounds&&!n&&!e&&!ue(i,this.boundsPolygon))return!1;const s=n?this.tins.bakw:this.tins.forw,o=n?this.indexedTins.bakw:this.indexedTins.forw,c=n?this.vertices_params.bakw:this.vertices_params.forw,h=n?this.centroid.bakw:this.centroid.forw,f=n?this.pointsWeightBuffer.bakw:this.pointsWeightBuffer.forw;let l,a;this.stateFull&&(this.stateBackward==n?l=this.stateTriangle:(this.stateBackward=n,this.stateTriangle=void 0),a=d=>{this.stateTriangle=d});let u=te(i,s,o,c,h,f,l,a);if(this.bounds&&n&&!e){const d=Wt(u);if(!ue(d,this.boundsPolygon))return!1}else this.yaxisMode==xt.YAXIS_FOLLOW&&!n&&(u=[u[0],-1*u[1]]);return u}};tt(_t,"VERTEX_PLAIN","plain"),tt(_t,"VERTEX_BIRDEYE","birdeye"),tt(_t,"MODE_STRICT","strict"),tt(_t,"MODE_AUTO","auto"),tt(_t,"MODE_LOOSE","loose"),tt(_t,"STATUS_STRICT","strict"),tt(_t,"STATUS_ERROR","strict_error"),tt(_t,"STATUS_LOOSE","loose"),tt(_t,"YAXIS_FOLLOW","follow"),tt(_t,"YAXIS_INVERT","invert");let An=_t;const gt=11102230246251565e-32,N=134217729,De=(3+8*gt)*gt;function ft(r,t,n,e,i){let s,o,c,h,f=t[0],l=e[0],a=0,u=0;l>f==l>-f?(s=f,f=t[++a]):(s=l,l=e[++u]);let d=0;if(a<r&&u<n)for(l>f==l>-f?(o=f+s,c=s-(o-f),f=t[++a]):(o=l+s,c=s-(o-l),l=e[++u]),s=o,c!==0&&(i[d++]=c);a<r&&u<n;)l>f==l>-f?(o=s+f,h=o-s,c=s-(o-h)+(f-h),f=t[++a]):(o=s+l,h=o-s,c=s-(o-h)+(l-h),l=e[++u]),s=o,c!==0&&(i[d++]=c);for(;a<r;)o=s+f,h=o-s,c=s-(o-h)+(f-h),f=t[++a],s=o,c!==0&&(i[d++]=c);for(;u<n;)o=s+l,h=o-s,c=s-(o-h)+(l-h),l=e[++u],s=o,c!==0&&(i[d++]=c);return(s!==0||d===0)&&(i[d++]=s),d}function kt(r,t,n,e,i,s,o,c){return ft(ft(r,t,n,e,o),o,i,s,c)}function x(r,t,n,e){let i,s,o,c,h,f,l,a,u,d,y;l=N*n,d=l-(l-n),y=n-d;let w=t[0];i=w*n,l=N*w,a=l-(l-w),u=w-a,o=u*y-(i-a*d-u*d-a*y);let m=0;o!==0&&(e[m++]=o);for(let p=1;p<r;p++)w=t[p],c=w*n,l=N*w,a=l-(l-w),u=w-a,h=u*y-(c-a*d-u*d-a*y),s=i+h,f=s-i,o=i-(s-f)+(h-f),o!==0&&(e[m++]=o),i=c+s,o=s-(i-c),o!==0&&(e[m++]=o);return(i!==0||m===0)&&(e[m++]=i),m}function Fe(r,t){let n=t[0];for(let e=1;e<r;e++)n+=t[e];return n}function Q(r){return new Float64Array(r)}const En=(3+16*gt)*gt,On=(2+12*gt)*gt,Tn=(9+64*gt)*gt*gt,Vt=Q(4),Ue=Q(8),Le=Q(12),Ve=Q(16),pt=Q(4);function In(r,t,n,e,i,s,o){let c,h,f,l,a,u,d,y,w,m,p,S,E,O,R,T,F,q;const L=r-i,st=n-i,it=t-s,z=e-s;O=L*z,u=N*L,d=u-(u-L),y=L-d,u=N*z,w=u-(u-z),m=z-w,R=y*m-(O-d*w-y*w-d*m),T=it*st,u=N*it,d=u-(u-it),y=it-d,u=N*st,w=u-(u-st),m=st-w,F=y*m-(T-d*w-y*w-d*m),p=R-F,a=R-p,Vt[0]=R-(p+a)+(a-F),S=O+p,a=S-O,E=O-(S-a)+(p-a),p=E-T,a=E-p,Vt[1]=E-(p+a)+(a-T),q=S+p,a=q-S,Vt[2]=S-(q-a)+(p-a),Vt[3]=q;let Z=Fe(4,Vt),g=On*o;if(Z>=g||-Z>=g||(a=r-L,c=r-(L+a)+(a-i),a=n-st,f=n-(st+a)+(a-i),a=t-it,h=t-(it+a)+(a-s),a=e-z,l=e-(z+a)+(a-s),c===0&&h===0&&f===0&&l===0)||(g=Tn*o+De*Math.abs(Z),Z+=L*l+z*c-(it*f+st*h),Z>=g||-Z>=g))return Z;O=c*z,u=N*c,d=u-(u-c),y=c-d,u=N*z,w=u-(u-z),m=z-w,R=y*m-(O-d*w-y*w-d*m),T=h*st,u=N*h,d=u-(u-h),y=h-d,u=N*st,w=u-(u-st),m=st-w,F=y*m-(T-d*w-y*w-d*m),p=R-F,a=R-p,pt[0]=R-(p+a)+(a-F),S=O+p,a=S-O,E=O-(S-a)+(p-a),p=E-T,a=E-p,pt[1]=E-(p+a)+(a-T),q=S+p,a=q-S,pt[2]=S-(q-a)+(p-a),pt[3]=q;const b=ft(4,Vt,4,pt,Ue);O=L*l,u=N*L,d=u-(u-L),y=L-d,u=N*l,w=u-(u-l),m=l-w,R=y*m-(O-d*w-y*w-d*m),T=it*f,u=N*it,d=u-(u-it),y=it-d,u=N*f,w=u-(u-f),m=f-w,F=y*m-(T-d*w-y*w-d*m),p=R-F,a=R-p,pt[0]=R-(p+a)+(a-F),S=O+p,a=S-O,E=O-(S-a)+(p-a),p=E-T,a=E-p,pt[1]=E-(p+a)+(a-T),q=S+p,a=q-S,pt[2]=S-(q-a)+(p-a),pt[3]=q;const _=ft(b,Ue,4,pt,Le);O=c*l,u=N*c,d=u-(u-c),y=c-d,u=N*l,w=u-(u-l),m=l-w,R=y*m-(O-d*w-y*w-d*m),T=h*f,u=N*h,d=u-(u-h),y=h-d,u=N*f,w=u-(u-f),m=f-w,F=y*m-(T-d*w-y*w-d*m),p=R-F,a=R-p,pt[0]=R-(p+a)+(a-F),S=O+p,a=S-O,E=O-(S-a)+(p-a),p=E-T,a=E-p,pt[1]=E-(p+a)+(a-T),q=S+p,a=q-S,pt[2]=S-(q-a)+(p-a),pt[3]=q;const M=ft(_,Le,4,pt,Ve);return Ve[M-1]}function Yt(r,t,n,e,i,s){const o=(t-s)*(n-i),c=(r-i)*(e-s),h=o-c,f=Math.abs(o+c);return Math.abs(h)>=En*f?h:-In(r,t,n,e,i,s,f)}const Nn=(10+96*gt)*gt,Cn=(4+48*gt)*gt,Rn=(44+576*gt)*gt*gt,Nt=Q(4),Ct=Q(4),Rt=Q(4),St=Q(4),vt=Q(4),At=Q(4),mt=Q(4),bt=Q(4),le=Q(8),de=Q(8),ge=Q(8),we=Q(8),pe=Q(8),me=Q(8),ne=Q(8),se=Q(8),ie=Q(8),$t=Q(4),Dt=Q(4),Ft=Q(4),B=Q(8),U=Q(16),et=Q(16),nt=Q(16),K=Q(32),Bt=Q(32),ot=Q(48),yt=Q(64);let qt=Q(1152),be=Q(1152);function rt(r,t,n){r=ft(r,qt,t,n,be);const e=qt;return qt=be,be=e,r}function Bn(r,t,n,e,i,s,o,c,h){let f,l,a,u,d,y,w,m,p,S,E,O,R,T,F,q,L,st,it,z,Z,g,b,_,M,v,C,k,A,j,I,P,$,V,D;const X=r-o,W=n-o,Y=i-o,G=t-c,J=e-c,H=s-c;I=W*H,b=N*W,_=b-(b-W),M=W-_,b=N*H,v=b-(b-H),C=H-v,P=M*C-(I-_*v-M*v-_*C),$=Y*J,b=N*Y,_=b-(b-Y),M=Y-_,b=N*J,v=b-(b-J),C=J-v,V=M*C-($-_*v-M*v-_*C),k=P-V,g=P-k,Nt[0]=P-(k+g)+(g-V),A=I+k,g=A-I,j=I-(A-g)+(k-g),k=j-$,g=j-k,Nt[1]=j-(k+g)+(g-$),D=A+k,g=D-A,Nt[2]=A-(D-g)+(k-g),Nt[3]=D,I=Y*G,b=N*Y,_=b-(b-Y),M=Y-_,b=N*G,v=b-(b-G),C=G-v,P=M*C-(I-_*v-M*v-_*C),$=X*H,b=N*X,_=b-(b-X),M=X-_,b=N*H,v=b-(b-H),C=H-v,V=M*C-($-_*v-M*v-_*C),k=P-V,g=P-k,Ct[0]=P-(k+g)+(g-V),A=I+k,g=A-I,j=I-(A-g)+(k-g),k=j-$,g=j-k,Ct[1]=j-(k+g)+(g-$),D=A+k,g=D-A,Ct[2]=A-(D-g)+(k-g),Ct[3]=D,I=X*J,b=N*X,_=b-(b-X),M=X-_,b=N*J,v=b-(b-J),C=J-v,P=M*C-(I-_*v-M*v-_*C),$=W*G,b=N*W,_=b-(b-W),M=W-_,b=N*G,v=b-(b-G),C=G-v,V=M*C-($-_*v-M*v-_*C),k=P-V,g=P-k,Rt[0]=P-(k+g)+(g-V),A=I+k,g=A-I,j=I-(A-g)+(k-g),k=j-$,g=j-k,Rt[1]=j-(k+g)+(g-$),D=A+k,g=D-A,Rt[2]=A-(D-g)+(k-g),Rt[3]=D,f=ft(ft(ft(x(x(4,Nt,X,B),B,X,U),U,x(x(4,Nt,G,B),B,G,et),et,K),K,ft(x(x(4,Ct,W,B),B,W,U),U,x(x(4,Ct,J,B),B,J,et),et,Bt),Bt,yt),yt,ft(x(x(4,Rt,Y,B),B,Y,U),U,x(x(4,Rt,H,B),B,H,et),et,K),K,qt);let It=Fe(f,qt),Ht=Cn*h;if(It>=Ht||-It>=Ht||(g=r-X,l=r-(X+g)+(g-o),g=t-G,d=t-(G+g)+(g-c),g=n-W,a=n-(W+g)+(g-o),g=e-J,y=e-(J+g)+(g-c),g=i-Y,u=i-(Y+g)+(g-o),g=s-H,w=s-(H+g)+(g-c),l===0&&a===0&&u===0&&d===0&&y===0&&w===0)||(Ht=Rn*h+De*Math.abs(It),It+=(X*X+G*G)*(W*w+H*a-(J*u+Y*y))+2*(X*l+G*d)*(W*H-J*Y)+((W*W+J*J)*(Y*d+G*u-(H*l+X*w))+2*(W*a+J*y)*(Y*G-H*X))+((Y*Y+H*H)*(X*y+J*l-(G*a+W*d))+2*(Y*u+H*w)*(X*J-G*W)),It>=Ht||-It>=Ht))return It;if((a!==0||y!==0||u!==0||w!==0)&&(I=X*X,b=N*X,_=b-(b-X),M=X-_,P=M*M-(I-_*_-(_+_)*M),$=G*G,b=N*G,_=b-(b-G),M=G-_,V=M*M-($-_*_-(_+_)*M),k=P+V,g=k-P,St[0]=P-(k-g)+(V-g),A=I+k,g=A-I,j=I-(A-g)+(k-g),k=j+$,g=k-j,St[1]=j-(k-g)+($-g),D=A+k,g=D-A,St[2]=A-(D-g)+(k-g),St[3]=D),(u!==0||w!==0||l!==0||d!==0)&&(I=W*W,b=N*W,_=b-(b-W),M=W-_,P=M*M-(I-_*_-(_+_)*M),$=J*J,b=N*J,_=b-(b-J),M=J-_,V=M*M-($-_*_-(_+_)*M),k=P+V,g=k-P,vt[0]=P-(k-g)+(V-g),A=I+k,g=A-I,j=I-(A-g)+(k-g),k=j+$,g=k-j,vt[1]=j-(k-g)+($-g),D=A+k,g=D-A,vt[2]=A-(D-g)+(k-g),vt[3]=D),(l!==0||d!==0||a!==0||y!==0)&&(I=Y*Y,b=N*Y,_=b-(b-Y),M=Y-_,P=M*M-(I-_*_-(_+_)*M),$=H*H,b=N*H,_=b-(b-H),M=H-_,V=M*M-($-_*_-(_+_)*M),k=P+V,g=k-P,At[0]=P-(k-g)+(V-g),A=I+k,g=A-I,j=I-(A-g)+(k-g),k=j+$,g=k-j,At[1]=j-(k-g)+($-g),D=A+k,g=D-A,At[2]=A-(D-g)+(k-g),At[3]=D),l!==0&&(m=x(4,Nt,l,le),f=rt(f,kt(x(m,le,2*X,U),U,x(x(4,At,l,B),B,J,et),et,x(x(4,vt,l,B),B,-H,nt),nt,K,ot),ot)),d!==0&&(p=x(4,Nt,d,de),f=rt(f,kt(x(p,de,2*G,U),U,x(x(4,vt,d,B),B,Y,et),et,x(x(4,At,d,B),B,-W,nt),nt,K,ot),ot)),a!==0&&(S=x(4,Ct,a,ge),f=rt(f,kt(x(S,ge,2*W,U),U,x(x(4,St,a,B),B,H,et),et,x(x(4,At,a,B),B,-G,nt),nt,K,ot),ot)),y!==0&&(E=x(4,Ct,y,we),f=rt(f,kt(x(E,we,2*J,U),U,x(x(4,At,y,B),B,X,et),et,x(x(4,St,y,B),B,-Y,nt),nt,K,ot),ot)),u!==0&&(O=x(4,Rt,u,pe),f=rt(f,kt(x(O,pe,2*Y,U),U,x(x(4,vt,u,B),B,G,et),et,x(x(4,St,u,B),B,-J,nt),nt,K,ot),ot)),w!==0&&(R=x(4,Rt,w,me),f=rt(f,kt(x(R,me,2*H,U),U,x(x(4,St,w,B),B,W,et),et,x(x(4,vt,w,B),B,-X,nt),nt,K,ot),ot)),l!==0||d!==0){if(a!==0||y!==0||u!==0||w!==0?(I=a*H,b=N*a,_=b-(b-a),M=a-_,b=N*H,v=b-(b-H),C=H-v,P=M*C-(I-_*v-M*v-_*C),$=W*w,b=N*W,_=b-(b-W),M=W-_,b=N*w,v=b-(b-w),C=w-v,V=M*C-($-_*v-M*v-_*C),k=P+V,g=k-P,mt[0]=P-(k-g)+(V-g),A=I+k,g=A-I,j=I-(A-g)+(k-g),k=j+$,g=k-j,mt[1]=j-(k-g)+($-g),D=A+k,g=D-A,mt[2]=A-(D-g)+(k-g),mt[3]=D,I=u*-J,b=N*u,_=b-(b-u),M=u-_,b=N*-J,v=b-(b- -J),C=-J-v,P=M*C-(I-_*v-M*v-_*C),$=Y*-y,b=N*Y,_=b-(b-Y),M=Y-_,b=N*-y,v=b-(b- -y),C=-y-v,V=M*C-($-_*v-M*v-_*C),k=P+V,g=k-P,bt[0]=P-(k-g)+(V-g),A=I+k,g=A-I,j=I-(A-g)+(k-g),k=j+$,g=k-j,bt[1]=j-(k-g)+($-g),D=A+k,g=D-A,bt[2]=A-(D-g)+(k-g),bt[3]=D,F=ft(4,mt,4,bt,se),I=a*w,b=N*a,_=b-(b-a),M=a-_,b=N*w,v=b-(b-w),C=w-v,P=M*C-(I-_*v-M*v-_*C),$=u*y,b=N*u,_=b-(b-u),M=u-_,b=N*y,v=b-(b-y),C=y-v,V=M*C-($-_*v-M*v-_*C),k=P-V,g=P-k,Dt[0]=P-(k+g)+(g-V),A=I+k,g=A-I,j=I-(A-g)+(k-g),k=j-$,g=j-k,Dt[1]=j-(k+g)+(g-$),D=A+k,g=D-A,Dt[2]=A-(D-g)+(k-g),Dt[3]=D,st=4):(se[0]=0,F=1,Dt[0]=0,st=1),l!==0){const ut=x(F,se,l,nt);f=rt(f,ft(x(m,le,l,U),U,x(ut,nt,2*X,K),K,ot),ot);const lt=x(st,Dt,l,B);f=rt(f,kt(x(lt,B,2*X,U),U,x(lt,B,l,et),et,x(ut,nt,l,K),K,Bt,yt),yt),y!==0&&(f=rt(f,x(x(4,At,l,B),B,y,U),U)),w!==0&&(f=rt(f,x(x(4,vt,-l,B),B,w,U),U))}if(d!==0){const ut=x(F,se,d,nt);f=rt(f,ft(x(p,de,d,U),U,x(ut,nt,2*G,K),K,ot),ot);const lt=x(st,Dt,d,B);f=rt(f,kt(x(lt,B,2*G,U),U,x(lt,B,d,et),et,x(ut,nt,d,K),K,Bt,yt),yt)}}if(a!==0||y!==0){if(u!==0||w!==0||l!==0||d!==0?(I=u*G,b=N*u,_=b-(b-u),M=u-_,b=N*G,v=b-(b-G),C=G-v,P=M*C-(I-_*v-M*v-_*C),$=Y*d,b=N*Y,_=b-(b-Y),M=Y-_,b=N*d,v=b-(b-d),C=d-v,V=M*C-($-_*v-M*v-_*C),k=P+V,g=k-P,mt[0]=P-(k-g)+(V-g),A=I+k,g=A-I,j=I-(A-g)+(k-g),k=j+$,g=k-j,mt[1]=j-(k-g)+($-g),D=A+k,g=D-A,mt[2]=A-(D-g)+(k-g),mt[3]=D,z=-H,Z=-w,I=l*z,b=N*l,_=b-(b-l),M=l-_,b=N*z,v=b-(b-z),C=z-v,P=M*C-(I-_*v-M*v-_*C),$=X*Z,b=N*X,_=b-(b-X),M=X-_,b=N*Z,v=b-(b-Z),C=Z-v,V=M*C-($-_*v-M*v-_*C),k=P+V,g=k-P,bt[0]=P-(k-g)+(V-g),A=I+k,g=A-I,j=I-(A-g)+(k-g),k=j+$,g=k-j,bt[1]=j-(k-g)+($-g),D=A+k,g=D-A,bt[2]=A-(D-g)+(k-g),bt[3]=D,q=ft(4,mt,4,bt,ie),I=u*d,b=N*u,_=b-(b-u),M=u-_,b=N*d,v=b-(b-d),C=d-v,P=M*C-(I-_*v-M*v-_*C),$=l*w,b=N*l,_=b-(b-l),M=l-_,b=N*w,v=b-(b-w),C=w-v,V=M*C-($-_*v-M*v-_*C),k=P-V,g=P-k,Ft[0]=P-(k+g)+(g-V),A=I+k,g=A-I,j=I-(A-g)+(k-g),k=j-$,g=j-k,Ft[1]=j-(k+g)+(g-$),D=A+k,g=D-A,Ft[2]=A-(D-g)+(k-g),Ft[3]=D,it=4):(ie[0]=0,q=1,Ft[0]=0,it=1),a!==0){const ut=x(q,ie,a,nt);f=rt(f,ft(x(S,ge,a,U),U,x(ut,nt,2*W,K),K,ot),ot);const lt=x(it,Ft,a,B);f=rt(f,kt(x(lt,B,2*W,U),U,x(lt,B,a,et),et,x(ut,nt,a,K),K,Bt,yt),yt),w!==0&&(f=rt(f,x(x(4,St,a,B),B,w,U),U)),d!==0&&(f=rt(f,x(x(4,At,-a,B),B,d,U),U))}if(y!==0){const ut=x(q,ie,y,nt);f=rt(f,ft(x(E,we,y,U),U,x(ut,nt,2*J,K),K,ot),ot);const lt=x(it,Ft,y,B);f=rt(f,kt(x(lt,B,2*J,U),U,x(lt,B,y,et),et,x(ut,nt,y,K),K,Bt,yt),yt)}}if(u!==0||w!==0){if(l!==0||d!==0||a!==0||y!==0?(I=l*J,b=N*l,_=b-(b-l),M=l-_,b=N*J,v=b-(b-J),C=J-v,P=M*C-(I-_*v-M*v-_*C),$=X*y,b=N*X,_=b-(b-X),M=X-_,b=N*y,v=b-(b-y),C=y-v,V=M*C-($-_*v-M*v-_*C),k=P+V,g=k-P,mt[0]=P-(k-g)+(V-g),A=I+k,g=A-I,j=I-(A-g)+(k-g),k=j+$,g=k-j,mt[1]=j-(k-g)+($-g),D=A+k,g=D-A,mt[2]=A-(D-g)+(k-g),mt[3]=D,z=-G,Z=-d,I=a*z,b=N*a,_=b-(b-a),M=a-_,b=N*z,v=b-(b-z),C=z-v,P=M*C-(I-_*v-M*v-_*C),$=W*Z,b=N*W,_=b-(b-W),M=W-_,b=N*Z,v=b-(b-Z),C=Z-v,V=M*C-($-_*v-M*v-_*C),k=P+V,g=k-P,bt[0]=P-(k-g)+(V-g),A=I+k,g=A-I,j=I-(A-g)+(k-g),k=j+$,g=k-j,bt[1]=j-(k-g)+($-g),D=A+k,g=D-A,bt[2]=A-(D-g)+(k-g),bt[3]=D,T=ft(4,mt,4,bt,ne),I=l*y,b=N*l,_=b-(b-l),M=l-_,b=N*y,v=b-(b-y),C=y-v,P=M*C-(I-_*v-M*v-_*C),$=a*d,b=N*a,_=b-(b-a),M=a-_,b=N*d,v=b-(b-d),C=d-v,V=M*C-($-_*v-M*v-_*C),k=P-V,g=P-k,$t[0]=P-(k+g)+(g-V),A=I+k,g=A-I,j=I-(A-g)+(k-g),k=j-$,g=j-k,$t[1]=j-(k+g)+(g-$),D=A+k,g=D-A,$t[2]=A-(D-g)+(k-g),$t[3]=D,L=4):(ne[0]=0,T=1,$t[0]=0,L=1),u!==0){const ut=x(T,ne,u,nt);f=rt(f,ft(x(O,pe,u,U),U,x(ut,nt,2*Y,K),K,ot),ot);const lt=x(L,$t,u,B);f=rt(f,kt(x(lt,B,2*Y,U),U,x(lt,B,u,et),et,x(ut,nt,u,K),K,Bt,yt),yt),d!==0&&(f=rt(f,x(x(4,vt,u,B),B,d,U),U)),y!==0&&(f=rt(f,x(x(4,St,-u,B),B,y,U),U))}if(w!==0){const ut=x(T,ne,w,nt);f=rt(f,ft(x(R,me,w,U),U,x(ut,nt,2*H,K),K,ot),ot);const lt=x(L,$t,w,B);f=rt(f,kt(x(lt,B,2*H,U),U,x(lt,B,w,et),et,x(ut,nt,w,K),K,Bt,yt),yt)}}return qt[f-1]}function jn(r,t,n,e,i,s,o,c){const h=r-o,f=n-o,l=i-o,a=t-c,u=e-c,d=s-c,y=f*d,w=l*u,m=h*h+a*a,p=l*a,S=h*d,E=f*f+u*u,O=h*u,R=f*a,T=l*l+d*d,F=m*(y-w)+E*(p-S)+T*(O-R),q=(Math.abs(y)+Math.abs(w))*m+(Math.abs(p)+Math.abs(S))*E+(Math.abs(O)+Math.abs(R))*T,L=Nn*q;return F>L||-F>L?F:Bn(r,t,n,e,i,s,o,c,q)}class Pn{bs;width;constructor(t,n){this.width=t,this.bs=n}add(t){const n=Math.floor(t/this.width),e=t%this.width;return this.bs[n]|=1<<e,this}delete(t){const n=Math.floor(t/this.width),e=t%this.width;return this.bs[n]&=~(1<<e),this}set(t,n){const e=Math.floor(t/this.width),s=1<<t%this.width;return this.bs[e]^=(-Number(n)^this.bs[e])&s,n}has(t){const n=Math.floor(t/this.width),e=t%this.width;return(this.bs[n]&1<<e)!==0}forEach(t){const n=this.bs.length;for(let e=0;e<n;e++){let i=0;for(;this.bs[e]&&i<this.width;)this.bs[e]&1<<i&&t(e*this.width+i),i++}return this}}class qe extends Pn{constructor(t){super(8,new Uint8Array(Math.ceil(t/8)).fill(0))}}function Ut(r){return r%3===2?r-2:r+1}function Ot(r){return r%3===0?r+2:r-1}function ze(r,t,n,e,i,s,o,c){const h=Yt(r,t,i,s,o,c),f=Yt(n,e,i,s,o,c);if(h>0&&f>0||h<0&&f<0)return!1;const l=Yt(i,s,r,t,n,e),a=Yt(o,c,r,t,n,e);return l>0&&a>0||l<0&&a<0?!1:h===0&&f===0&&l===0&&a===0?!(Math.max(i,o)<Math.min(r,n)||Math.max(r,n)<Math.min(i,o)||Math.max(s,c)<Math.min(t,e)||Math.max(t,e)<Math.min(s,c)):!0}class $n{del;constructor(t){this.del=t}}class Dn extends $n{vertMap;flips;consd;constructor(t,n){if(!t||typeof t!="object"||!t.triangles||!t.halfedges||!t.coords)throw new Error("Expected an object with Delaunator output");if(t.triangles.length%3||t.halfedges.length!==t.triangles.length||t.coords.length%2)throw new Error("Delaunator output appears inconsistent");if(t.triangles.length<3)throw new Error("No edges in triangulation");super(t);const e=2**32-1,i=t.coords.length>>1,s=t.triangles.length;this.vertMap=new Uint32Array(i).fill(e),this.flips=new qe(s),this.consd=new qe(s);for(let o=0;o<s;o++){const c=t.triangles[o];this.vertMap[c]===e&&this.updateVert(o)}n&&this.constrainAll(n)}constrainOne(t,n){const{triangles:e,halfedges:i}=this.del,s=this.vertMap[t];let o=s;do{const f=e[o],l=Ut(o);if(f===n)return this.protect(o);const a=Ot(o),u=e[a];if(u===n)return this.protect(l),l;if(this.intersectSegments(t,n,u,f)){o=a;break}o=i[l]}while(o!==-1&&o!==s);let c=o,h=-1;for(;o!==-1;){const f=i[o],l=Ot(o),a=Ot(f),u=Ut(f);if(f===-1)throw new Error("Constraining edge exited the hull");if(this.consd.has(o))throw new Error("Edge intersects already constrained edge");if(this.isCollinear(t,n,e[o])||this.isCollinear(t,n,e[f]))throw new Error("Constraining edge intersects point");if(!this.intersectSegments(e[o],e[f],e[l],e[a])){if(h===-1&&(h=o),e[a]===n){if(o===h)throw new Error("Infinite loop: non-convex quadrilateral");o=h,h=-1;continue}if(this.intersectSegments(t,n,e[a],e[f]))o=a;else if(this.intersectSegments(t,n,e[u],e[a]))o=u;else if(h===o)throw new Error("Infinite loop: no further intersect after non-convex");continue}if(this.flipDiagonal(o),this.intersectSegments(t,n,e[l],e[a])&&(h===-1&&(h=l),h===l))throw new Error("Infinite loop: flipped diagonal still intersects");e[a]===n?(c=a,o=h,h=-1):this.intersectSegments(t,n,e[u],e[a])&&(o=u)}return this.protect(c),this.delaunify(!0),this.findEdge(t,n)}delaunify(t=!1){const{halfedges:n}=this.del,e=this.flips,i=this.consd,s=n.length;let o;do{o=0;for(let c=0;c<s;c++){if(i.has(c))continue;e.delete(c);const h=n[c];h!==-1&&(e.delete(h),this.isDelaunay(c)||(this.flipDiagonal(c),o++))}}while(t&&o>0);return this}constrainAll(t){const n=t.length;for(let e=0;e<n;e++){const i=t[e];this.constrainOne(i[0],i[1])}return this}isConstrained(t){return this.consd.has(t)}findEdge(t,n){const e=this.vertMap[n],{triangles:i,halfedges:s}=this.del;let o=e,c=-1;do{if(i[o]===t)return o;c=Ut(o),o=s[c]}while(o!==-1&&o!==e);return i[Ut(c)]===t?-c:1/0}protect(t){const n=this.del.halfedges[t],e=this.flips,i=this.consd;return e.delete(t),i.add(t),n!==-1?(e.delete(n),i.add(n),n):-t}markFlip(t){const n=this.del.halfedges,e=this.flips;if(this.consd.has(t))return!1;const s=n[t];return s!==-1&&(e.add(t),e.add(s)),!0}flipDiagonal(t){const{triangles:n,halfedges:e}=this.del,i=this.flips,s=this.consd,o=e[t],c=Ot(t),h=Ut(t),f=Ot(o),l=Ut(o),a=e[c],u=e[f];if(s.has(t))throw new Error("Trying to flip a constrained edge");return n[t]=n[f],e[t]=u,i.set(t,i.has(f))||s.set(t,s.has(f)),u!==-1&&(e[u]=t),e[c]=f,n[o]=n[c],e[o]=a,i.set(o,i.has(c))||s.set(o,s.has(c)),a!==-1&&(e[a]=o),e[f]=c,this.markFlip(t),this.markFlip(h),this.markFlip(o),this.markFlip(l),i.add(c),s.delete(c),i.add(f),s.delete(f),this.updateVert(t),this.updateVert(h),this.updateVert(o),this.updateVert(l),c}isCollinear(t,n,e){const i=this.del.coords;return Yt(i[t*2],i[t*2+1],i[n*2],i[n*2+1],i[e*2],i[e*2+1])===0}inCircle(t,n,e,i){const s=this.del.coords;return jn(s[t*2],s[t*2+1],s[n*2],s[n*2+1],s[e*2],s[e*2+1],s[i*2],s[i*2+1])<0}isDelaunay(t){const{triangles:n,halfedges:e}=this.del,i=e[t];if(i===-1)return!0;const s=n[Ot(t)],o=n[t],c=n[Ut(t)],h=n[Ot(i)];return!this.inCircle(s,o,c,h)}updateVert(t){const{triangles:n,halfedges:e}=this.del,i=this.vertMap,s=n[t];let o=Ot(t),c=e[o];for(;c!==-1&&c!==t;)o=Ot(c),c=e[o];return i[s]=o,o}intersectSegments(t,n,e,i){const s=this.del.coords;return t===e||t===i||n===e||n===i?!1:ze(s[t*2],s[t*2+1],s[n*2],s[n*2+1],s[e*2],s[e*2+1],s[i*2],s[i*2+1])}static intersectSegments=ze}function Jt(r,t,n){if(t||(t=[]),typeof r!="object"||r.type!=="FeatureCollection")throw"Argument points must be FeatureCollection";if(!Array.isArray(t))throw"Argument points must be Array of Array";const e=r.features.map(h=>h.geometry.coordinates),i=cn.from(e);let s;const o=[];i.triangles.length!==0&&t.length!==0&&(s=new Dn(i),s.constrainAll(t));for(let h=0;h<i.triangles.length;h+=3)o.push([i.triangles[h],i.triangles[h+1],i.triangles[h+2]]);const c=["a","b","c"];return at.featureCollection(o.map(h=>{const f={},l=h.map((a,u)=>{const d=r.features[a],y=d.geometry.coordinates,w=[y[0],y[1]];return y.length===3?w[2]=y[2]:f[c[u]]=d.properties[n],w});return l[3]=l[0],at.polygon([l],f)}))}function Xe(r,t,n,e,i,s){return Object.keys(r).reduce((o,c)=>{const h=r[c],f=h.forw,l=h.bakw,a={forw:[f[0]-t.forw[0],f[1]-t.forw[1]],bakw:[l[0]-t.bakw[0],l[1]-t.bakw[1]]},u=a.forw[0]===0?1/0:((a.forw[0]<0?n:e)-t.forw[0])/a.forw[0],d=a.forw[1]===0?1/0:((a.forw[1]<0?i:s)-t.forw[1])/a.forw[1];if(Math.abs(u)/Math.abs(d)<1.1){const y={forw:[a.forw[0]*u+t.forw[0],a.forw[1]*u+t.forw[1]],bakw:[a.bakw[0]*u+t.bakw[0],a.bakw[1]*u+t.bakw[1]]};a.forw[0]<0?o[3].push(y):o[1].push(y)}if(Math.abs(d)/Math.abs(u)<1.1){const y={forw:[a.forw[0]*d+t.forw[0],a.forw[1]*d+t.forw[1]],bakw:[a.bakw[0]*d+t.bakw[0],a.bakw[1]*d+t.bakw[1]]};a.forw[1]<0?o[0].push(y):o[2].push(y)}return o},[[],[],[],[]])}function Fn(r,t){const n=[[],[],[],[]],e=[];return Object.keys(r).forEach(i=>{const s=r[i],o=s.forw,c=s.bakw,h=[o[0]-t.forw[0],o[1]-t.forw[1]],f=[c[0]-t.bakw[0],t.bakw[1]-c[1]],l={forw:h,bakw:f};if(e.push(l),h[0]===0||h[1]===0)return;let a=0;h[0]>0&&(a+=1),h[1]>0&&(a+=2),n[a].push(l)}),{perQuad:n,aggregate:e}}function Un(r){let t=1/0,n=0,e=0;return r.forEach(i=>{const{forw:s,bakw:o}=i,c=Math.hypot(s[0],s[1]),h=Math.hypot(o[0],o[1]);if(h===0)return;const f=c/h,l=Math.atan2(s[0],s[1])-Math.atan2(o[0],o[1]);t=Math.min(t,f),n+=Math.cos(l),e+=Math.sin(l)}),isFinite(t)?[t,Math.atan2(e,n)]:[1,0]}function We(r,t,n){const{perQuad:e,aggregate:i}=Fn(r,t),s=e.every(h=>h.length>0);let o;n==="birdeye"&&s?o=e:n==="birdeye"?o=[i]:s?o=e:o=[i];const c=o.map(h=>Un(h));return c.length===1?[c[0],c[0],c[0],c[0]]:c}function Ln(r,t,n){const e=[1,1,1,1];for(let i=0;i<4;i++){const s=(i+1)%4,o=at.lineString([r[i].bakw,r[s].bakw]);t[i].map(c=>{const h=at.lineString([n.bakw,c.bakw]),f=an(o,h);if(f.features.length>0&&f.features[0].geometry){const l=f.features[0],a=Math.sqrt(Math.pow(c.bakw[0]-n.bakw[0],2)+Math.pow(c.bakw[1]-n.bakw[1],2)),u=Math.sqrt(Math.pow(l.geometry.coordinates[0]-n.bakw[0],2)+Math.pow(l.geometry.coordinates[1]-n.bakw[1],2)),d=a/u;d>e[i]&&(e[i]=d),d>e[s]&&(e[s]=d)}})}r.forEach((i,s)=>{const o=e[s],c=[(i.bakw[0]-n.bakw[0])*o+n.bakw[0],(i.bakw[1]-n.bakw[1])*o+n.bakw[1]];i.bakw=c})}function Ye(r,t,n,e){const i=r.map((o,c)=>{const h=t[c],f=[h[0]-n.forw[0],h[1]-n.forw[1]],a=Math.sqrt(Math.pow(f[0],2)+Math.pow(f[1],2))/o[0],u=Math.atan2(f[0],f[1])-o[1],d=[n.bakw[0]+a*Math.sin(u),n.bakw[1]-a*Math.cos(u)];return{forw:h,bakw:d}}),s=i[2];return i[2]=i[3],i[3]=s,Ln(i,e,n),i}function Vn(r){const{convexBuf:t,centroid:n,bbox:e,minx:i,maxx:s,miny:o,maxy:c}=r,h=Xe(t,n,i,s,o,c),f=We(t,n,"plain");return Ye(f,e,n,h)}function qn(r){const{convexBuf:t,centroid:n,bbox:e,minx:i,maxx:s,miny:o,maxy:c}=r,h=Xe(t,n,i,s,o,c),f=We(t,n,"birdeye");return Ye(f,e,n,h)}function Je(r){const n=new zn(r).findSegmentIntersections();return tn(n).reduce((e,i,s,o)=>Array.isArray(e)||(e||(e={}),e[`${i.x}:${i.y}`]=i,s!=o.length-1)?e:Object.keys(e).map(c=>at.point([e[c].x,e[c].y])),{})}class zn{_xx;_yy;_ii;_nn;_zz;_zlimit=0;_bb;_allBounds;_arcIter;_filteredArcIter;buf;constructor(t){this.initArcs(t)}initArcs(t){const n=[],e=[],i=t.map(s=>{const o=s?s.length:0;for(let c=0;c<o;c++)n.push(s[c][0]),e.push(s[c][1]);return o});this.initXYData(i,n,e)}initXYData(t,n,e){const i=t.length;this._xx=new Float64Array(n),this._yy=new Float64Array(e),this._nn=new Uint32Array(t),this._zz=null,this._zlimit=0,this._filteredArcIter=null,this._ii=new Uint32Array(i);let s=0;for(let o=0;o<i;o++)this._ii[o]=s,s+=t[o];(s!=this._xx.length||this._xx.length!=this._yy.length)&&ye("ArcCollection#initXYData() Counting error"),this.initBounds(),this._arcIter=new hs(this._xx,this._yy)}initBounds(){const t=this.calcArcBounds_(this._xx,this._yy,this._nn);this._bb=t.bb,this._allBounds=t.bounds}calcArcBounds_(t,n,e){const i=e.length,s=new Float64Array(i*4),o=new ce;let c=0,h,f,l;for(let a=0;a<i;a++)h=e[a],h>0&&(f=a*4,l=us(t,n,c,h),s[f++]=l[0],s[f++]=l[1],s[f++]=l[2],s[f]=l[3],c+=h,o.mergeBounds(l));return{bb:s,bounds:o}}getBounds(){return this._allBounds.clone()}forEachSegment(t){let n=0;for(let e=0,i=this.size();e<i;e++)n+=this.forEachArcSegment(e,t);return n}size(){return this._ii&&this._ii.length||0}forEachArcSegment(t,n){const e=t>=0,i=e?t:~t,s=this.getRetainedInterval(),o=this._nn[i],c=e?1:-1;let h=e?this._ii[i]:this._ii[i]+o-1,f=h,l=0;for(let a=1;a<o;a++)f+=c,(s===0||this._zz[f]>=s)&&(n(h,f,this._xx,this._yy),h=f,l++);return l}getRetainedInterval(){return this._zlimit}getVertexData(){return{xx:this._xx,yy:this._yy,zz:this._zz,bb:this._bb,nn:this._nn,ii:this._ii}}getUint32Array(t){const n=t*4;return(!this.buf||this.buf.byteLength<n)&&(this.buf=new ArrayBuffer(n)),new Uint32Array(this.buf,0,t)}getAvgSegment2(){let t=0,n=0;const e=this.forEachSegment((i,s,o,c)=>{t+=Math.abs(o[i]-o[s]),n+=Math.abs(c[i]-c[s])});return[t/e||0,n/e||0]}calcSegmentIntersectionStripeCount(){const t=this.getBounds().height(),n=this.getAvgSegment2()[1];let e=1;return n>0&&t>0&&(e=Math.ceil(t/n/20)),e||1}findSegmentIntersections(){const t=this.getBounds(),n=t.ymin,e=t.ymax-n,i=this.calcSegmentIntersectionStripeCount(),s=new Uint32Array(i),o=i>1?w=>Math.floor((i-1)*(w-n)/e):()=>0;let c,h;this.forEachSegment((w,m,p,S)=>{let E=o(S[w]);const O=o(S[m]);for(;s[E]=s[E]+2,E!=O;)E+=O>E?1:-1});const f=this.getUint32Array(Yn(s));let l=0;const a=[];Jn(s,w=>{const m=l;l+=w,a.push(f.subarray(m,l))}),Qn(s,0),this.forEachSegment((w,m,p,S)=>{let E=o(S[w]);const O=o(S[m]);let R,T;for(;R=s[E],s[E]=R+2,T=a[E],T[R]=w,T[R+1]=m,E!=O;)E+=O>E?1:-1});const u=this.getVertexData(),d=[];let y;for(c=0;c<i;c++)for(y=Kn(a[c],u.xx,u.yy),h=0;h<y.length;h++)d.push(y[h]);return tn(d)}}function ye(...r){const t=r.join(" ");throw new Error(t)}function ke(r){return r?Wn(r)?!0:Xn(r)?!1:r.length===0?!0:r.length>0:!1}function Xn(r){return r!=null&&r.toString===String.prototype.toString}function Wn(r){return Array.isArray(r)}function Yn(r,t){ke(r)||ye("utils.sum() expects an array, received:",r);let n=0,e;for(let i=0,s=r.length;i<s;i++)e=r[i],e&&(n+=e);return n}function Jn(r,t,n){if(!ke(r))throw new Error(`#forEach() takes an array-like argument. ${r}`);for(let e=0,i=r.length;e<i;e++)t.call(n,r[e],e)}function Qn(r,t){for(let n=0,e=r.length;n<e;n++)r[n]=t;return r}function Kn(r,t,n){const e=r.length-2,i=[];let s,o,c,h,f,l,a,u,d,y,w,m,p,S,E,O,R;for(rs(t,r),O=0;O<e;){for(s=r[O],o=r[O+1],f=t[s],l=t[o],d=n[s],y=n[o],R=O;R<e&&(R+=2,c=r[R],a=t[c],!(l<a));){if(w=n[c],h=r[R+1],u=t[h],m=n[h],d>=w){if(d>m&&y>w&&y>m)continue}else if(d<m&&y<w&&y<m)continue;s==c||s==h||o==c||o==h||(p=Gn(f,d,l,y,a,w,u,m),p&&(S=[s,o],E=[c,h],i.push(He(p,S,E,t,n)),p.length==4&&i.push(He(p.slice(2),S,E,t,n))))}O+=2}return i}function Gn(r,t,n,e,i,s,o,c){const h=Hn(r,t,n,e,i,s,o,c);let f=null;return h&&(f=Zn(r,t,n,e,i,s,o,c),f?os(r,t,n,e,i,s,o,c)&&(f=null):f=is(r,t,n,e,i,s,o,c)),f}function Hn(r,t,n,e,i,s,o,c){return Qt(r,t,n,e,i,s)*Qt(r,t,n,e,o,c)<=0&&Qt(i,s,o,c,r,t)*Qt(i,s,o,c,n,e)<=0}function Qt(r,t,n,e,i,s){return Qe(r-i,t-s,n-i,e-s)}function Qe(r,t,n,e){return r*e-t*n}function Zn(r,t,n,e,i,s,o,c){let h=oe(r,t,n,e,i,s,o,c),f;return h&&(f=es(h[0],h[1],r,t,n,e,i,s,o,c),f==1?h=oe(n,e,r,t,i,s,o,c):f==2?h=oe(i,s,o,c,r,t,n,e):f==3&&(h=oe(o,c,i,s,r,t,n,e))),h&&ss(h,r,t,n,e,i,s,o,c),h}function oe(r,t,n,e,i,s,o,c){const h=Qe(n-r,e-t,o-i,c-s),f=1e-18;let l;if(h===0)return null;const a=Qt(i,s,o,c,r,t)/h;return h<=f&&h>=-f?l=ts(r,t,n,e,i,s,o,c):l=[r+a*(n-r),t+a*(e-t)],l}function ts(r,t,n,e,i,s,o,c){let h=null;return!Tt(r,i,o)&&!Tt(t,s,c)?h=[r,t]:!Tt(n,i,o)&&!Tt(e,s,c)?h=[n,e]:!Tt(i,r,n)&&!Tt(s,t,e)?h=[i,s]:!Tt(o,r,n)&&!Tt(c,t,e)&&(h=[o,c]),h}function Tt(r,t,n){let e;return t<n?e=r<t||r>n:t>n?e=r>t||r<n:e=r!=t,e}function es(r,t,...n){let e=-1,i=1/0,s;for(let o=0,c=0,h=n.length;c<h;o++,c+=2)s=ns(r,t,n[c],n[c+1]),s<i&&(i=s,e=o);return e}function ns(r,t,n,e){const i=r-n,s=t-e;return i*i+s*s}function ss(r,t,n,e,i,s,o,c,h){let f=r[0],l=r[1];f=re(f,t,e),f=re(f,s,c),l=re(l,n,i),l=re(l,o,h),r[0]=f,r[1]=l}function re(r,t,n){let e;return Tt(r,t,n)&&(e=Math.abs(r-t)<Math.abs(r-n)?t:n,r=e),r}function is(r,t,n,e,i,s,o,c){const h=Math.min(r,n,i,o),f=Math.max(r,n,i,o),l=Math.min(t,e,s,c),a=Math.max(t,e,s,c),u=a-l>f-h;let d=[];return(u?jt(t,l,a):jt(r,h,f))&&d.push(r,t),(u?jt(e,l,a):jt(n,h,f))&&d.push(n,e),(u?jt(s,l,a):jt(i,h,f))&&d.push(i,s),(u?jt(c,l,a):jt(o,h,f))&&d.push(o,c),(d.length!=2&&d.length!=4||d.length==4&&d[0]==d[2]&&d[1]==d[3])&&(d=null),d}function os(r,t,n,e,i,s,o,c){return r==i&&t==s||r==o&&t==c||n==i&&e==s||n==o&&e==c}function jt(r,t,n){return r>t&&r<n}function rs(r,t){cs(r,t),Ke(r,t,0,t.length-2)}function cs(r,t){for(let n=0,e=t.length;n<e;n+=2)r[t[n]]>r[t[n+1]]&&as(t,n,n+1)}function as(r,t,n){const e=r[t];r[t]=r[n],r[n]=e}function Ke(r,t,n,e){let i=n,s=e,o,c;for(;i<e;){for(o=r[t[n+e>>2<<1]];i<=s;){for(;r[t[i]]<o;)i+=2;for(;r[t[s]]>o;)s-=2;i<=s&&(c=t[i],t[i]=t[s],t[s]=c,c=t[i+1],t[i+1]=t[s+1],t[s+1]=c,i+=2,s-=2)}if(s-n<40?Ge(r,t,n,s):Ke(r,t,n,s),e-i<40){Ge(r,t,i,e);return}n=i,s=e}}function Ge(r,t,n,e){let i,s;for(let o=n+2;o<=e;o+=2){i=t[o],s=t[o+1];let c;for(c=o-2;c>=n&&r[i]<r[t[c]];c-=2)t[c+2]=t[c],t[c+3]=t[c+1];t[c+2]=i,t[c+3]=s}}function He(r,t,n,e,i){const s=r[0],o=r[1];t=Ze(s,o,t[0],t[1],e,i),n=Ze(s,o,n[0],n[1],e,i);const c=t[0]<n[0]?t:n,h=c==t?n:t;return{x:s,y:o,a:c,b:h}}function Ze(r,t,n,e,i,s){let o=n<e?n:e,c=o===n?e:n;return i[o]==r&&s[o]==t?c=o:i[c]==r&&s[c]==t&&(o=c),[o,c]}function tn(r){const t={};return r.filter(n=>{const e=fs(n);return e in t?!1:(t[e]=!0,!0)})}function fs(r){return`${r.a.join(",")};${r.b.join(",")}`}class hs{_i=0;_n=0;_inc=1;_xx;_yy;i=0;x=0;y=0;constructor(t,n){this._xx=t,this._yy=n}}function us(r,t,n,e){let i=n|0;const s=isNaN(e)?r.length-i:e+i;let o,c,h,f,l,a;if(s>0)h=l=r[i],f=a=t[i];else return[void 0,void 0,void 0,void 0];for(i++;i<s;i++)o=r[i],c=t[i],o<h&&(h=o),o>l&&(l=o),c<f&&(f=c),c>a&&(a=c);return[h,f,l,a]}class ce{xmin;ymin;xmax;ymax;constructor(...t){t.length>0&&this.setBounds(t)}cloneBounds(){return this.clone()}clone(){return new ce(this.xmin,this.ymin,this.xmax,this.ymax)}width(){return this.xmax-this.xmin||0}height(){return this.ymax-this.ymin||0}setBounds(t,n,e,i){return arguments.length==1&&(ke(t)?(n=t[1],e=t[2],i=t[3],t=t[0]):(n=t.ymin,e=t.xmax,i=t.ymax,t=t.xmin)),this.xmin=t,this.ymin=n,this.xmax=e,this.ymax=i,(t>e||n>i)&&this.update(),this}update(){let t;this.xmin>this.xmax&&(t=this.xmin,this.xmin=this.xmax,this.xmax=t),this.ymin>this.ymax&&(t=this.ymin,this.ymin=this.ymax,this.ymax=t)}mergeBounds(t,...n){let e,i,s,o;return t instanceof ce?(e=t.xmin,i=t.ymin,s=t.xmax,o=t.ymax):n.length==3?(e=t,i=n[0],s=n[1],o=n[2]):t.length==4?(e=t[0],i=t[1],s=t[2],o=t[3]):ye("Bounds#mergeBounds() invalid argument:",t),this.xmin===void 0?this.setBounds(e,i,s,o):(e<this.xmin&&(this.xmin=e),i<this.ymin&&(this.ymin=i),s>this.xmax&&(this.xmax=s),o>this.ymax&&(this.ymax=o)),this}}function ae(r){const t=["a","b","c"].map(n=>r.properties[n].index);return[[0,1],[0,2],[1,2],[0,1,2]].map(n=>n.map(e=>t[e]).sort().join("-")).sort()}function _e(r,t,n){const e=ae(t.forw),i=ae(t.bakw);if(JSON.stringify(e)!=JSON.stringify(i))throw`${JSON.stringify(t,null,2)}
${JSON.stringify(e)}
${JSON.stringify(i)}`;for(let s=0;s<e.length;s++){const o=e[s];r[o]||(r[o]=[]),r[o].push(t)}n&&(n.forw.features.push(t.forw),n.bakw.features.push(t.bakw))}function en(r,t,n){const e=ae(t.forw),i=ae(t.bakw);if(JSON.stringify(e)!=JSON.stringify(i))throw`${JSON.stringify(t,null,2)}
${JSON.stringify(e)}
${JSON.stringify(i)}`;if(e.forEach(s=>{const o=r[s];if(!o)return;const c=o.filter(h=>h!==t);c.length===0?delete r[s]:r[s]=c}),n){const s=(o,c)=>{!o||!c||(o.features=o.features.filter(h=>h!==c))};s(n.forw,t.forw),s(n.bakw,t.bakw)}}function Kt(r,t,n){return at.point(r,{target:{geom:t,index:n}})}function Gt(r){return at.point(r.properties.target.geom,{target:{geom:r.geometry.coordinates,index:r.properties.target.index}})}function xe(r,t){const n=t.geometry.coordinates;return[0,1,2,3].map(e=>{const i=(e+1)%4,s=r[e],o=r[i],c=s.geometry.coordinates,h=Math.atan2(c[0]-n[0],c[1]-n[1]),f=[t,s,o,t].map(u=>u.geometry.coordinates),l={a:{geom:t.properties.target.geom,index:t.properties.target.index},b:{geom:s.properties.target.geom,index:s.properties.target.index},c:{geom:o.properties.target.geom,index:o.properties.target.index}},a=at.featureCollection([at.polygon([f],l)]);return[h,a]}).reduce((e,i)=>(e[0].push(i[0]),e[1].push(i[1]),e),[[],[]])}function ls(r){const{tins:t,targets:n,includeReciprocals:e}=r,i={};n.forEach(o=>{const c=t[o];if(!c||!c.features)return;i[o]={};const h={};c.features.forEach(f=>{const l=["a","b","c"];for(let a=0;a<3;a++){const u=(a+1)%3,d=l[a],y=l[u],w=f.properties[d].index,m=f.properties[y].index,p=[w,m].sort().join("-");if(h[p])continue;h[p]=!0;const S=f.geometry.coordinates[0][a],E=f.geometry.coordinates[0][u],O=f.properties[d].geom,R=f.properties[y].geom,T=Math.sqrt(Math.pow(O[0]-R[0],2)+Math.pow(O[1]-R[1],2))/Math.sqrt(Math.pow(S[0]-E[0],2)+Math.pow(S[1]-E[1],2)),F=i[o];F[`${w}:${p}`]=T,F[`${m}:${p}`]=T}})});const s={};return e&&(s.bakw={}),n.forEach(o=>{const c=i[o];if(s[o]={},!c)return;const h={};Object.keys(c).forEach(l=>{const[a]=l.split(":");h[a]||(h[a]=[]),h[a].push(c[l])}),Object.keys(h).forEach(l=>{const a=h[l],u=a.reduce((d,y)=>d+y,0)/a.length;s[o][l]=u,e&&s.bakw&&(s.bakw[l]=1/u)});let f=0;for(let l=0;l<4;l++){const a=`b${l}`,u=s[o][a]||0;f+=u}s[o].c=f/4,e&&s.bakw&&(s.bakw.c=1/s[o].c)}),s}function ds(r,t){const n=r.split("-");if(n.length!==2||!n.every(s=>/^-?\d+$/.test(s)))return!1;const[e,i]=n.map(s=>parseInt(s,10)).sort((s,o)=>s-o);return t.some(s=>{if(s.length!==2)return!1;const o=s.map(h=>parseInt(`${h}`,10));if(o.some(h=>Number.isNaN(h)))return!1;const c=o.sort((h,f)=>h-f);return c[0]===e&&c[1]===i})}function nn(r){return["a","b","c"].map((t,n)=>({prop:r.properties[t],geom:r.geometry.coordinates[0][n]}))}function gs(r,t,n){let e=!1,i=!0;for(;i;){i=!1;const s=Object.keys(t);for(const o of s){const c=t[o];if(!c||c.length<2||ds(o,n))continue;const h=o.split("-"),f=nn(c[0].bakw),l=nn(c[1].bakw),a=h.map(m=>f.find(p=>`${p.prop.index}`===m)||l.find(p=>`${p.prop.index}`===m));if(a.some(m=>!m))continue;const u=[f,l].map(m=>m.find(p=>!h.includes(`${p.prop.index}`)));if(u.some(m=>!m))continue;const d=c[0].bakw.geometry.coordinates[0].slice(0,3).map(m=>fe(m)),y=c[1].bakw.geometry.coordinates[0].slice(0,3).map(m=>fe(m));if(sn(fe(u[0].geom),y)||sn(fe(u[1].geom),d)){en(t,c[0],r),en(t,c[1],r),a.forEach(m=>{if(!m)return;const p=[m.geom,u[0].geom,u[1].geom,m.geom],S={a:m.prop,b:u[0].prop,c:u[1].prop},E=at.polygon([p],S),O=Ce(E);_e(t,{forw:O,bakw:E},r)}),e=!0,i=!0;break}}}return e}function fe(r){return[r[0],r[1]]}function sn(r,t){const[n,e]=t[0],[i,s]=t[1],[o,c]=t[2],h=o-n,f=c-e,l=i-n,a=s-e,u=r[0]-n,d=r[1]-e,y=h*h+f*f,w=h*l+f*a,m=h*u+f*d,p=l*l+a*a,S=l*u+a*d,E=y*p-w*w;if(E===0)return!1;const O=1/E,R=(p*m-w*S)*O,T=(y*S-w*m)*O,F=1e-9;return R>=-F&&T>=-F&&R+T<=1+F}const on=ee;class ct extends An{importance;priority;pointsSet;constructor(t={}){super(),t.bounds?this.setBounds(t.bounds):(this.setWh(t.wh),this.vertexMode=t.vertexMode||ct.VERTEX_PLAIN),this.strictMode=t.strictMode||ct.MODE_AUTO,this.yaxisMode=t.yaxisMode||ct.YAXIS_INVERT,this.importance=t.importance||0,this.priority=t.priority||0,this.stateFull=t.stateFull||!1,t.points&&this.setPoints(t.points),t.edges&&this.setEdges(t.edges)}getFormatVersion(){return on}setPoints(t){this.yaxisMode===ct.YAXIS_FOLLOW&&(t=t.map(n=>[n[0],[n[1][0],-1*n[1][1]]])),this.points=t,this.tins=void 0,this.indexedTins=void 0}setEdges(t=[]){this.edges=Be(t),this.edgeNodes=void 0,this.tins=void 0,this.indexedTins=void 0}setBounds(t){this.bounds=t;let n=t[0][0],e=n,i=t[0][1],s=i;const o=[t[0]];for(let c=1;c<t.length;c++){const h=t[c];h[0]<n&&(n=h[0]),h[0]>e&&(e=h[0]),h[1]<i&&(i=h[1]),h[1]>s&&(s=h[1]),o.push(h)}o.push(t[0]),this.boundsPolygon=at.polygon([o]),this.xy=[n,i],this.wh=[e-n,s-i],this.vertexMode=ct.VERTEX_PLAIN,this.tins=void 0,this.indexedTins=void 0}getCompiled(){const t={};t.version=on,t.points=this.points,t.weight_buffer=this.pointsWeightBuffer,t.centroid_point=[this.centroid.forw.geometry.coordinates,this.centroid.forw.properties.target.geom],t.vertices_params=[this.vertices_params.forw[0],this.vertices_params.bakw[0]],t.vertices_points=[];const n=this.vertices_params.forw[1];return n&&[0,1,2,3].map(e=>{const i=n[e].features[0],s=i.geometry.coordinates[0][1],o=i.properties.b.geom;t.vertices_points[e]=[s,o]}),t.strict_status=this.strict_status,t.tins_points=[[]],this.tins.forw.features.map(e=>{t.tins_points[0].push(["a","b","c"].map(i=>e.properties[i].index))}),this.strict_status===ct.STATUS_LOOSE?(t.tins_points[1]=[],this.tins.bakw.features.map(e=>{t.tins_points[1].push(["a","b","c"].map(i=>e.properties[i].index))})):this.strict_status===ct.STATUS_ERROR&&this.kinks?.bakw&&(t.kinks_points=this.kinks.bakw.features.map(e=>e.geometry.coordinates)),t.yaxisMode=this.yaxisMode,t.vertexMode=this.vertexMode,t.strictMode=this.strictMode,this.bounds?(t.bounds=this.bounds,t.boundsPolygon=this.boundsPolygon,t.xy=this.xy,t.wh=this.wh):t.wh=this.wh,t.edges=this.edges,t.edgeNodes=this.edgeNodes,t}setWh(t){this.wh=t||[100,100],this.xy=[0,0],this.bounds=void 0,this.boundsPolygon=void 0,this.tins=void 0,this.indexedTins=void 0}setVertexMode(t){this.vertexMode=t,this.tins=void 0,this.indexedTins=void 0}setStrictMode(t){this.strictMode=t,this.tins=void 0,this.indexedTins=void 0}calcurateStrictTin(){const t=this.tins.forw.features.map(i=>Ce(i));this.tins.bakw=at.featureCollection(t);const n={};this.tins.forw.features.forEach((i,s)=>{const o=this.tins.bakw.features[s];_e(n,{forw:i,bakw:o})}),gs(this.tins,n,this.pointsSet?.edges||[]);const e=["forw","bakw"].map(i=>{const s=this.tins[i].features.map(o=>o.geometry.coordinates[0]);return Je(s)});e[0].length===0&&e[1].length===0?(this.strict_status=ct.STATUS_STRICT,delete this.kinks):(this.strict_status=ct.STATUS_ERROR,this.kinks={},e[0].length>0&&(this.kinks.forw=at.featureCollection(e[0])),e[1].length>0&&(this.kinks.bakw=at.featureCollection(e[1])))}generatePointsSet(){const t={forw:[],bakw:[]};for(let i=0;i<this.points.length;i++){const s=this.points[i][0],o=this.points[i][1],c=Kt(s,o,i);t.forw.push(c),t.bakw.push(Gt(c))}const n=[];let e=0;this.edgeNodes=[],this.edges||(this.edges=[]);for(let i=0;i<this.edges.length;i++){const s=this.edges[i][2],o=Object.assign([],this.edges[i][0]),c=Object.assign([],this.edges[i][1]);if(o.length===0&&c.length===0){n.push(s);continue}o.unshift(this.points[s[0]][0]),o.push(this.points[s[1]][0]),c.unshift(this.points[s[0]][1]),c.push(this.points[s[1]][1]);const h=[o,c].map(f=>{const l=f.map((u,d,y)=>{if(d===0)return 0;const w=y[d-1];return Math.sqrt(Math.pow(u[0]-w[0],2)+Math.pow(u[1]-w[1],2))}),a=l.reduce((u,d,y)=>y===0?[0]:(u.push(u[y-1]+d),u),[]);return a.map((u,d,y)=>{const w=u/y[y.length-1];return[f[d],l[d],a[d],w]})});h.map((f,l)=>{const a=h[l?0:1];return f.filter((u,d)=>!(d===0||d===f.length-1||u[4]==="handled")).map(u=>{const d=u[0],y=u[3],w=a.reduce((m,p,S,E)=>{if(m)return m;const O=E[S+1];if(p[3]===y)return p[4]="handled",[p];if(p[3]<y&&O&&O[3]>y)return[p,O]},void 0);if(w&&w.length===1)return l===0?[d,w[0][0],y]:[w[0][0],d,y];if(w&&w.length===2){const m=w[0],p=w[1],S=(y-m[3])/(p[3]-m[3]),E=[(p[0][0]-m[0][0])*S+m[0][0],(p[0][1]-m[0][1])*S+m[0][1]];return l===0?[d,E,y]:[E,d,y]}return[]})}).reduce((f,l)=>f.concat(l),[]).sort((f,l)=>f[2]<l[2]?-1:1).map((f,l,a)=>{this.edgeNodes[e]=[f[0],f[1]];const u=Kt(f[0],f[1],`e${e}`);e++,t.forw.push(u),t.bakw.push(Gt(u)),l===0?n.push([s[0],t.forw.length-1]):n.push([t.forw.length-2,t.forw.length-1]),l===a.length-1&&n.push([t.forw.length-1,s[1]])})}return{forw:t.forw,bakw:t.bakw,edges:n}}validateAndPrepareInputs(){const t=this.xy[0]-.05*this.wh[0],n=this.xy[0]+1.05*this.wh[0],e=this.xy[1]-.05*this.wh[1],i=this.xy[1]+1.05*this.wh[1];if(!this.points.reduce((c,h)=>c&&(this.bounds?zt(h[0],this.boundsPolygon):h[0][0]>=t&&h[0][0]<=n&&h[0][1]>=e&&h[0][1]<=i),!0))throw"SOME POINTS OUTSIDE";let o=[];return this.wh&&(o=[[t,e],[n,e],[t,i],[n,i]]),{pointsSet:this.generatePointsSet(),bbox:o,minx:t,maxx:n,miny:e,maxy:i}}updateTin(){let t=this.strictMode;t!==ct.MODE_STRICT&&t!==ct.MODE_LOOSE&&(t=ct.MODE_AUTO);const{pointsSet:n,bbox:e,minx:i,maxx:s,miny:o,maxy:c}=this.validateAndPrepareInputs(),h={forw:at.featureCollection(n.forw),bakw:at.featureCollection(n.bakw)},f=Jt(h.forw,n.edges,"target"),l=Jt(h.bakw,n.edges,"target");if(f.features.length===0||l.features.length===0)throw"TOO LINEAR1";const a=rn(h.forw),u=Me(h.forw);if(!u)throw"TOO LINEAR2";const d={},y=u.geometry.coordinates[0];let w;try{w=y.map(L=>({forw:L,bakw:te(at.point(L),f)})),w.forEach(L=>{d[`${L.forw[0]}:${L.forw[1]}`]=L})}catch{throw"TOO LINEAR2"}const m=Me(h.bakw);if(!m)throw"TOO LINEAR2";const p=m.geometry.coordinates[0];try{w=p.map(L=>({bakw:L,forw:te(at.point(L),l)})),w.forEach(L=>{d[`${L.forw[0]}:${L.forw[1]}`]=L})}catch{throw"TOO LINEAR2"}const S={forw:a.geometry.coordinates,bakw:te(a,f)},E=Kt(S.forw,S.bakw,"c");this.centroid={forw:E,bakw:Gt(E)};const O={convexBuf:d,centroid:S,bbox:e,minx:i,maxx:s,miny:o,maxy:c},R=this.vertexMode===ct.VERTEX_BIRDEYE?qn(O):Vn(O),T={forw:[],bakw:[]};for(let L=0;L<R.length;L++){const st=R[L].forw,it=R[L].bakw,z=Kt(st,it,`b${L}`),Z=Gt(z);n.forw.push(z),n.bakw.push(Z),T.forw.push(z),T.bakw.push(Z)}this.pointsSet={forw:at.featureCollection(n.forw),bakw:at.featureCollection(n.bakw),edges:n.edges},this.tins={forw:Ne(Jt(this.pointsSet.forw,n.edges,"target"))},(t===ct.MODE_STRICT||t===ct.MODE_AUTO)&&this.calcurateStrictTin(),(t===ct.MODE_LOOSE||t===ct.MODE_AUTO&&this.strict_status===ct.STATUS_ERROR)&&(this.tins.bakw=Ne(Jt(this.pointsSet.bakw,n.edges,"target")),delete this.kinks,this.strict_status=ct.STATUS_LOOSE),this.vertices_params={forw:xe(T.forw,this.centroid.forw),bakw:xe(T.bakw,this.centroid.bakw)},this.addIndexedTin();const F=["forw"];this.strict_status===ct.STATUS_LOOSE&&F.push("bakw");const q=this.strict_status===ct.STATUS_STRICT;this.pointsWeightBuffer=ls({tins:this.tins,targets:F,includeReciprocals:q})}async updateTinAsync(){this.updateTin()}}ht.Tin=ct,ht.constrainedTin=Jt,ht.counterPoint=Gt,ht.createPoint=Kt,ht.findIntersections=Je,ht.format_version=ee,ht.insertSearchIndex=_e,ht.vertexCalc=xe,Object.defineProperty(ht,Symbol.toStringTag,{value:"Module"})}));
