(function(ft,Yt){typeof exports=="object"&&typeof module<"u"?Yt(exports,require("@turf/boolean-point-in-polygon"),require("@turf/centroid"),require("@turf/convex"),require("@turf/helpers"),require("@turf/line-intersect")):typeof define=="function"&&define.amd?define(["exports","@turf/boolean-point-in-polygon","@turf/centroid","@turf/convex","@turf/helpers","@turf/line-intersect"],Yt):(ft=typeof globalThis<"u"?globalThis:ft||self,Yt(ft.tin={},ft.turf.booleanPointInPolygon,ft.turf.centroid,ft.turf.convex,ft.turf.helpers,ft.turf.lineIntersect))})(this,(function(ft,Yt,un,Te,at,dn){"use strict";var gn=Object.defineProperty,wn=(r,t,e)=>t in r?gn(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e,nt=(r,t,e)=>wn(r,typeof t!="symbol"?t+"":t,e);const Et=11102230246251565e-32,dt=134217729,pn=(3+8*Et)*Et;function de(r,t,e,n,o){let s,i,c,f,h=t[0],u=n[0],a=0,l=0;u>h==u>-h?(s=h,h=t[++a]):(s=u,u=n[++l]);let d=0;if(a<r&&l<e)for(u>h==u>-h?(i=h+s,c=s-(i-h),h=t[++a]):(i=u+s,c=s-(i-u),u=n[++l]),s=i,c!==0&&(o[d++]=c);a<r&&l<e;)u>h==u>-h?(i=s+h,f=i-s,c=s-(i-f)+(h-f),h=t[++a]):(i=s+u,f=i-s,c=s-(i-f)+(u-f),u=n[++l]),s=i,c!==0&&(o[d++]=c);for(;a<r;)i=s+h,f=i-s,c=s-(i-f)+(h-f),h=t[++a],s=i,c!==0&&(o[d++]=c);for(;l<e;)i=s+u,f=i-s,c=s-(i-f)+(u-f),u=n[++l],s=i,c!==0&&(o[d++]=c);return(s!==0||d===0)&&(o[d++]=s),d}function mn(r,t){let e=t[0];for(let n=1;n<r;n++)e+=t[n];return e}function Wt(r){return new Float64Array(r)}const bn=(3+16*Et)*Et,yn=(2+12*Et)*Et,_n=(9+64*Et)*Et*Et,zt=Wt(4),Ie=Wt(8),Oe=Wt(12),Ne=Wt(16),wt=Wt(4);function kn(r,t,e,n,o,s,i){let c,f,h,u,a,l,d,m,g,b,p,S,v,I,R,N,j,X;const E=r-o,V=e-o,L=t-s,z=n-s;I=E*z,l=dt*E,d=l-(l-E),m=E-d,l=dt*z,g=l-(l-z),b=z-g,R=m*b-(I-d*g-m*g-d*b),N=L*V,l=dt*L,d=l-(l-L),m=L-d,l=dt*V,g=l-(l-V),b=V-g,j=m*b-(N-d*g-m*g-d*b),p=R-j,a=R-p,zt[0]=R-(p+a)+(a-j),S=I+p,a=S-I,v=I-(S-a)+(p-a),p=v-N,a=v-p,zt[1]=v-(p+a)+(a-N),X=S+p,a=X-S,zt[2]=S-(X-a)+(p-a),zt[3]=X;let W=mn(4,zt),w=yn*i;if(W>=w||-W>=w||(a=r-E,c=r-(E+a)+(a-o),a=e-V,h=e-(V+a)+(a-o),a=t-L,f=t-(L+a)+(a-s),a=n-z,u=n-(z+a)+(a-s),c===0&&f===0&&h===0&&u===0)||(w=_n*i+pn*Math.abs(W),W+=E*u+z*c-(L*h+V*f),W>=w||-W>=w))return W;I=c*z,l=dt*c,d=l-(l-c),m=c-d,l=dt*z,g=l-(l-z),b=z-g,R=m*b-(I-d*g-m*g-d*b),N=f*V,l=dt*f,d=l-(l-f),m=f-d,l=dt*V,g=l-(l-V),b=V-g,j=m*b-(N-d*g-m*g-d*b),p=R-j,a=R-p,wt[0]=R-(p+a)+(a-j),S=I+p,a=S-I,v=I-(S-a)+(p-a),p=v-N,a=v-p,wt[1]=v-(p+a)+(a-N),X=S+p,a=X-S,wt[2]=S-(X-a)+(p-a),wt[3]=X;const y=de(4,zt,4,wt,Ie);I=E*u,l=dt*E,d=l-(l-E),m=E-d,l=dt*u,g=l-(l-u),b=u-g,R=m*b-(I-d*g-m*g-d*b),N=L*h,l=dt*L,d=l-(l-L),m=L-d,l=dt*h,g=l-(l-h),b=h-g,j=m*b-(N-d*g-m*g-d*b),p=R-j,a=R-p,wt[0]=R-(p+a)+(a-j),S=I+p,a=S-I,v=I-(S-a)+(p-a),p=v-N,a=v-p,wt[1]=v-(p+a)+(a-N),X=S+p,a=X-S,wt[2]=S-(X-a)+(p-a),wt[3]=X;const _=de(y,Ie,4,wt,Oe);I=c*u,l=dt*c,d=l-(l-c),m=c-d,l=dt*u,g=l-(l-u),b=u-g,R=m*b-(I-d*g-m*g-d*b),N=f*h,l=dt*f,d=l-(l-f),m=f-d,l=dt*h,g=l-(l-h),b=h-g,j=m*b-(N-d*g-m*g-d*b),p=R-j,a=R-p,wt[0]=R-(p+a)+(a-j),S=I+p,a=S-I,v=I-(S-a)+(p-a),p=v-N,a=v-p,wt[1]=v-(p+a)+(a-N),X=S+p,a=X-S,wt[2]=S-(X-a)+(p-a),wt[3]=X;const x=de(_,Oe,4,wt,Ne);return Ne[x-1]}function xn(r,t,e,n,o,s){const i=(t-s)*(e-o),c=(r-o)*(n-s),f=i-c,h=Math.abs(i+c);return Math.abs(f)>=bn*h?f:-kn(r,t,e,n,o,s,h)}function Sn(r,t){var e,n,o=0,s,i,c,f,h,u,a,l=r[0],d=r[1],m=t.length;for(e=0;e<m;e++){n=0;var g=t[e],b=g.length-1;if(u=g[0],u[0]!==g[b][0]&&u[1]!==g[b][1])throw new Error("First and last coordinates in a ring must be the same");for(i=u[0]-l,c=u[1]-d,n;n<b;n++){if(a=g[n+1],f=a[0]-l,h=a[1]-d,c===0&&h===0){if(f<=0&&i>=0||i<=0&&f>=0)return 0}else if(h>=0&&c<=0||h<=0&&c>=0){if(s=xn(i,f,c,h,0,0),s===0)return 0;(s>0&&h>0&&c<=0||s<0&&h<=0&&c>0)&&o++}u=a,c=h,i=f}}return o%2!==0}function Ce(r,t,e={}){const n={type:"Feature"};return(e.id===0||e.id)&&(n.id=e.id),e.bbox&&(n.bbox=e.bbox),n.properties=t||{},n.geometry=r,n}function Jt(r,t,e={}){if(!r)throw new Error("coordinates is required");if(!Array.isArray(r))throw new Error("coordinates must be an Array");if(r.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!Be(r[0])||!Be(r[1]))throw new Error("coordinates must contain numbers");return Ce({type:"Point",coordinates:r},t,e)}function Re(r,t,e={}){for(const n of r){if(n.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");if(n[n.length-1].length!==n[0].length)throw new Error("First and last Position are not equivalent.");for(let o=0;o<n[n.length-1].length;o++)if(n[n.length-1][o]!==n[0][o])throw new Error("First and last Position are not equivalent.")}return Ce({type:"Polygon",coordinates:r},t,e)}function Ut(r,t={}){const e={type:"FeatureCollection"};return t.id&&(e.id=t.id),t.bbox&&(e.bbox=t.bbox),e.features=r,e}function Be(r){return!isNaN(r)&&r!==null&&!Array.isArray(r)}function Mn(r){if(!r)throw new Error("coord is required");if(!Array.isArray(r)){if(r.type==="Feature"&&r.geometry!==null&&r.geometry.type==="Point")return[...r.geometry.coordinates];if(r.type==="Point")return[...r.coordinates]}if(Array.isArray(r)&&r.length>=2&&!Array.isArray(r[0])&&!Array.isArray(r[1]))return[...r];throw new Error("coord must be GeoJSON Point or an Array of numbers")}function Pe(r){if(Array.isArray(r))return r;if(r.type==="Feature"){if(r.geometry!==null)return r.geometry.coordinates}else if(r.coordinates)return r.coordinates;throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")}function An(r){return r.type==="Feature"?r.geometry:r}function vn(r,t,e={}){if(!r)throw new Error("point is required");if(!t)throw new Error("polygon is required");const n=Mn(r),o=An(t),s=o.type,i=t.bbox;let c=o.coordinates;if(i&&En(n,i)===!1)return!1;s==="Polygon"&&(c=[c]);let f=!1;for(var h=0;h<c.length;++h){const u=Sn(n,c[h]);if(u===0)return!e.ignoreBoundary;u&&(f=!0)}return f}function En(r,t){return t[0]<=r[0]&&t[1]<=r[1]&&t[2]>=r[0]&&t[3]>=r[1]}var ge=vn;function je(r){const t=r.features;for(let e=0;e<t.length;e++){const n=t[e];`${n.properties.a.index}`.substring(0,1)==="b"&&`${n.properties.b.index}`.substring(0,1)==="b"?t[e]={geometry:{type:"Polygon",coordinates:[[n.geometry.coordinates[0][2],n.geometry.coordinates[0][0],n.geometry.coordinates[0][1],n.geometry.coordinates[0][2]]]},properties:{a:{geom:n.properties.c.geom,index:n.properties.c.index},b:{geom:n.properties.a.geom,index:n.properties.a.index},c:{geom:n.properties.b.geom,index:n.properties.b.index}},type:"Feature"}:`${n.properties.c.index}`.substring(0,1)==="b"&&`${n.properties.a.index}`.substring(0,1)==="b"&&(t[e]={geometry:{type:"Polygon",coordinates:[[n.geometry.coordinates[0][1],n.geometry.coordinates[0][2],n.geometry.coordinates[0][0],n.geometry.coordinates[0][1]]]},properties:{a:{geom:n.properties.b.geom,index:n.properties.b.index},b:{geom:n.properties.c.geom,index:n.properties.c.index},c:{geom:n.properties.a.geom,index:n.properties.a.index}},type:"Feature"})}return r}function Ue(r){const t=["a","b","c","a"].map(s=>r.properties[s].geom),e=r.geometry.coordinates[0],n=r.properties,o={a:{geom:e[0],index:n.a.index},b:{geom:e[1],index:n.b.index},c:{geom:e[2],index:n.c.index}};return Re([t],o)}function Tn(r){const t=[0,1,2,0].map(n=>r[n][0][0]),e={a:{geom:r[0][0][1],index:r[0][1]},b:{geom:r[1][0][1],index:r[1][1]},c:{geom:r[2][0][1],index:r[2][1]}};return Re([t],e)}function ee(r,t,e,n,o,s=!1,i){const c=r.map(f=>{(!i||i<2.00703)&&(f=De(f));const h=isFinite(f)?t[f]:f==="c"?n:f==="b0"?o[0]:f==="b1"?o[1]:f==="b2"?o[2]:f==="b3"?o[3]:(function(){const u=f.match(/e(\d+)/);if(u){const a=parseInt(u[1]);return e[a]}throw"Bad index value for indexesToTri"})();return s?[[h[1],h[0]],f]:[[h[0],h[1]],f]});return Tn(c)}function De(r){return typeof r=="number"?r:r.replace(/^(c|e|b)(?:ent|dgeNode|box)(\d+)?$/,"$1$2")}function $e(r,t){return t&&t>=2.00703||Array.isArray(r[0])?r:r.map(e=>[e.illstNodes,e.mercNodes,e.startEnd])}function Fe(r,t){for(let e=0;e<t.features.length;e++)if(ge(r,t.features[e]))return t.features[e]}function Le(r,t,e){const n=t.geometry.coordinates[0][0],o=t.geometry.coordinates[0][1],s=t.geometry.coordinates[0][2],i=r.geometry.coordinates,c=t.properties.a.geom,f=t.properties.b.geom,h=t.properties.c.geom,u=[o[0]-n[0],o[1]-n[1]],a=[s[0]-n[0],s[1]-n[1]],l=[i[0]-n[0],i[1]-n[1]],d=[f[0]-c[0],f[1]-c[1]],m=[h[0]-c[0],h[1]-c[1]];let g=(a[1]*l[0]-a[0]*l[1])/(u[0]*a[1]-u[1]*a[0]),b=(u[0]*l[1]-u[1]*l[0])/(u[0]*a[1]-u[1]*a[0]);if(e){const p=e[t.properties.a.index],S=e[t.properties.b.index],v=e[t.properties.c.index];let I;if(g<0||b<0||1-g-b<0){const R=g/(g+b),N=b/(g+b);I=g/S/(R/S+N/v),b=b/v/(R/S+N/v)}else I=g/S/(g/S+b/v+(1-g-b)/p),b=b/v/(g/S+b/v+(1-g-b)/p);g=I}return[g*d[0]+b*m[0]+c[0],g*d[1]+b*m[1]+c[1]]}function In(r,t,e,n){const o=r.geometry.coordinates,s=e.geometry.coordinates,i=Math.atan2(o[0]-s[0],o[1]-s[1]),c=On(i,t[0]);if(c===void 0)throw new Error("Unable to determine vertex index");const f=t[1][c];return Le(r,f.features[0],n)}function ne(r,t,e,n,o,s,i,c){let f;if(i&&(f=Fe(r,Ut([i]))),!f){if(e){const h=r.geometry.coordinates,u=e.gridNum,a=e.xOrigin,l=e.yOrigin,d=e.xUnit,m=e.yUnit,g=e.gridCache,b=St(h[0],a,d,u),p=St(h[1],l,m,u),S=g[b]?g[b][p]?g[b][p]:[]:[];t=Ut(S.map(v=>t.features[v]))}f=Fe(r,t)}return c&&c(f),f?Le(r,f,s):In(r,n,o,s)}function St(r,t,e,n){let o=Math.floor((r-t)/e);return o>=n&&(o=n-1),o}function On(r,t){let e=ze(r-t[0]),n=Math.PI*2,o;for(let s=0;s<t.length;s++){const i=(s+1)%t.length,c=ze(r-t[i]),f=Math.min(Math.abs(e),Math.abs(c));e*c<=0&&f<n&&(n=f,o=s),e=c}return o}function ze(r,t=!1){const e=t?function(n){return!(n>=0&&n<Math.PI*2)}:function(n){return!(n>-1*Math.PI&&n<=Math.PI)};for(;e(r);)r=r+2*Math.PI*(r>0?-1:1);return r}const se=2.00703,kt=class xt{constructor(){nt(this,"points",[]),nt(this,"pointsWeightBuffer"),nt(this,"strict_status"),nt(this,"vertices_params"),nt(this,"centroid"),nt(this,"edgeNodes"),nt(this,"edges"),nt(this,"tins"),nt(this,"kinks"),nt(this,"yaxisMode",xt.YAXIS_INVERT),nt(this,"strictMode",xt.MODE_AUTO),nt(this,"vertexMode",xt.VERTEX_PLAIN),nt(this,"bounds"),nt(this,"boundsPolygon"),nt(this,"wh"),nt(this,"xy"),nt(this,"indexedTins"),nt(this,"stateFull",!1),nt(this,"stateTriangle"),nt(this,"stateBackward")}setCompiled(t){if(t.version||!t.tins&&t.points&&t.tins_points){this.points=t.points,this.pointsWeightBuffer=!t.version||t.version<2.00703?["forw","bakw"].reduce((n,o)=>{const s=t.weight_buffer[o];return s&&(n[o]=Object.keys(s).reduce((i,c)=>{const f=De(c);return i[f]=s[c],i},{})),n},{}):t.weight_buffer,t.strict_status?this.strict_status=t.strict_status:t.kinks_points?this.strict_status=xt.STATUS_ERROR:t.tins_points.length==2?this.strict_status=xt.STATUS_LOOSE:this.strict_status=xt.STATUS_STRICT,this.vertices_params={forw:[t.vertices_params[0]],bakw:[t.vertices_params[1]]},this.vertices_params.forw[1]=[0,1,2,3].map(n=>{const o=(n+1)%4,s=ee(["c",`b${n}`,`b${o}`],t.points,t.edgeNodes||[],t.centroid_point,t.vertices_points,!1,se);return Ut([s])}),this.vertices_params.bakw[1]=[0,1,2,3].map(n=>{const o=(n+1)%4,s=ee(["c",`b${n}`,`b${o}`],t.points,t.edgeNodes||[],t.centroid_point,t.vertices_points,!0,se);return Ut([s])}),this.centroid={forw:Jt(t.centroid_point[0],{target:{geom:t.centroid_point[1],index:"c"}}),bakw:Jt(t.centroid_point[1],{target:{geom:t.centroid_point[0],index:"c"}})},this.edges=$e(t.edges||[]),this.edgeNodes=t.edgeNodes||[];const e=t.tins_points.length==1?0:1;this.tins={forw:Ut(t.tins_points[0].map(n=>ee(n,t.points,t.edgeNodes||[],t.centroid_point,t.vertices_points,!1,t.version))),bakw:Ut(t.tins_points[e].map(n=>ee(n,t.points,t.edgeNodes||[],t.centroid_point,t.vertices_points,!0,t.version)))},this.addIndexedTin(),t.kinks_points&&(this.kinks={bakw:Ut(t.kinks_points.map(n=>Jt(n)))}),t.yaxisMode?this.yaxisMode=t.yaxisMode:this.yaxisMode=xt.YAXIS_INVERT,t.vertexMode&&(this.vertexMode=t.vertexMode),t.strictMode&&(this.strictMode=t.strictMode),t.bounds?(this.bounds=t.bounds,this.boundsPolygon=t.boundsPolygon,this.xy=t.xy,this.wh=t.wh):(this.xy=[0,0],t.wh&&(this.wh=t.wh),this.bounds=void 0,this.boundsPolygon=void 0)}else{t=JSON.parse(JSON.stringify(t).replace('"cent"','"c"').replace(/"bbox(\d+)"/g,'"b$1"')),this.tins=t.tins,this.addIndexedTin(),this.strict_status=t.strict_status,this.pointsWeightBuffer=t.weight_buffer,this.vertices_params=t.vertices_params,this.centroid=t.centroid,this.kinks=t.kinks;const e=[];for(let n=0;n<this.tins.forw.features.length;n++){const o=this.tins.forw.features[n];["a","b","c"].map((s,i)=>{const c=o.geometry.coordinates[0][i],f=o.properties[s].geom,h=o.properties[s].index;typeof h=="number"&&(e[h]=[c,f])})}this.points=e}}addIndexedTin(){const t=this.tins,e=t.forw,n=t.bakw,o=Math.ceil(Math.sqrt(e.features.length));if(o<3){this.indexedTins=void 0;return}let s=[],i=[];const c=e.features.map(g=>{let b=[];return Pe(g)[0].map(p=>{s.length===0?s=[Array.from(p),Array.from(p)]:(p[0]<s[0][0]&&(s[0][0]=p[0]),p[0]>s[1][0]&&(s[1][0]=p[0]),p[1]<s[0][1]&&(s[0][1]=p[1]),p[1]>s[1][1]&&(s[1][1]=p[1])),b.length===0?b=[Array.from(p),Array.from(p)]:(p[0]<b[0][0]&&(b[0][0]=p[0]),p[0]>b[1][0]&&(b[1][0]=p[0]),p[1]<b[0][1]&&(b[0][1]=p[1]),p[1]>b[1][1]&&(b[1][1]=p[1]))}),b}),f=(s[1][0]-s[0][0])/o,h=(s[1][1]-s[0][1])/o,u=c.reduce((g,b,p)=>{const S=St(b[0][0],s[0][0],f,o),v=St(b[1][0],s[0][0],f,o),I=St(b[0][1],s[0][1],h,o),R=St(b[1][1],s[0][1],h,o);for(let N=S;N<=v;N++){g[N]||(g[N]=[]);for(let j=I;j<=R;j++)g[N][j]||(g[N][j]=[]),g[N][j].push(p)}return g},[]),a=n.features.map(g=>{let b=[];return Pe(g)[0].map(p=>{i.length===0?i=[Array.from(p),Array.from(p)]:(p[0]<i[0][0]&&(i[0][0]=p[0]),p[0]>i[1][0]&&(i[1][0]=p[0]),p[1]<i[0][1]&&(i[0][1]=p[1]),p[1]>i[1][1]&&(i[1][1]=p[1])),b.length===0?b=[Array.from(p),Array.from(p)]:(p[0]<b[0][0]&&(b[0][0]=p[0]),p[0]>b[1][0]&&(b[1][0]=p[0]),p[1]<b[0][1]&&(b[0][1]=p[1]),p[1]>b[1][1]&&(b[1][1]=p[1]))}),b}),l=(i[1][0]-i[0][0])/o,d=(i[1][1]-i[0][1])/o,m=a.reduce((g,b,p)=>{const S=St(b[0][0],i[0][0],l,o),v=St(b[1][0],i[0][0],l,o),I=St(b[0][1],i[0][1],d,o),R=St(b[1][1],i[0][1],d,o);for(let N=S;N<=v;N++){g[N]||(g[N]=[]);for(let j=I;j<=R;j++)g[N][j]||(g[N][j]=[]),g[N][j].push(p)}return g},[]);this.indexedTins={forw:{gridNum:o,xOrigin:s[0][0],yOrigin:s[0][1],xUnit:f,yUnit:h,gridCache:u},bakw:{gridNum:o,xOrigin:i[0][0],yOrigin:i[0][1],xUnit:l,yUnit:d,gridCache:m}}}transform(t,e,n){if(e&&this.strict_status==xt.STATUS_ERROR)throw'Backward transform is not allowed if strict_status == "strict_error"';this.yaxisMode==xt.YAXIS_FOLLOW&&e&&(t=[t[0],-1*t[1]]);const o=Jt(t);if(this.bounds&&!e&&!n&&!ge(o,this.boundsPolygon))return!1;const s=e?this.tins.bakw:this.tins.forw,i=e?this.indexedTins.bakw:this.indexedTins.forw,c=e?this.vertices_params.bakw:this.vertices_params.forw,f=e?this.centroid.bakw:this.centroid.forw,h=e?this.pointsWeightBuffer.bakw:this.pointsWeightBuffer.forw;let u,a;this.stateFull&&(this.stateBackward==e?u=this.stateTriangle:(this.stateBackward=e,this.stateTriangle=void 0),a=d=>{this.stateTriangle=d});let l=ne(o,s,i,c,f,h,u,a);if(this.bounds&&e&&!n){const d=Jt(l);if(!ge(d,this.boundsPolygon))return!1}else this.yaxisMode==xt.YAXIS_FOLLOW&&!e&&(l=[l[0],-1*l[1]]);return l}};nt(kt,"VERTEX_PLAIN","plain"),nt(kt,"VERTEX_BIRDEYE","birdeye"),nt(kt,"MODE_STRICT","strict"),nt(kt,"MODE_AUTO","auto"),nt(kt,"MODE_LOOSE","loose"),nt(kt,"STATUS_STRICT","strict"),nt(kt,"STATUS_ERROR","strict_error"),nt(kt,"STATUS_LOOSE","loose"),nt(kt,"YAXIS_FOLLOW","follow"),nt(kt,"YAXIS_INVERT","invert");let Nn=kt;const gt=11102230246251565e-32,B=134217729,Ve=(3+8*gt)*gt;function ht(r,t,e,n,o){let s,i,c,f,h=t[0],u=n[0],a=0,l=0;u>h==u>-h?(s=h,h=t[++a]):(s=u,u=n[++l]);let d=0;if(a<r&&l<e)for(u>h==u>-h?(i=h+s,c=s-(i-h),h=t[++a]):(i=u+s,c=s-(i-u),u=n[++l]),s=i,c!==0&&(o[d++]=c);a<r&&l<e;)u>h==u>-h?(i=s+h,f=i-s,c=s-(i-f)+(h-f),h=t[++a]):(i=s+u,f=i-s,c=s-(i-f)+(u-f),u=n[++l]),s=i,c!==0&&(o[d++]=c);for(;a<r;)i=s+h,f=i-s,c=s-(i-f)+(h-f),h=t[++a],s=i,c!==0&&(o[d++]=c);for(;l<e;)i=s+u,f=i-s,c=s-(i-f)+(u-f),u=n[++l],s=i,c!==0&&(o[d++]=c);return(s!==0||d===0)&&(o[d++]=s),d}function _t(r,t,e,n,o,s,i,c){return ht(ht(r,t,e,n,i),i,o,s,c)}function A(r,t,e,n){let o,s,i,c,f,h,u,a,l,d,m;u=B*e,d=u-(u-e),m=e-d;let g=t[0];o=g*e,u=B*g,a=u-(u-g),l=g-a,i=l*m-(o-a*d-l*d-a*m);let b=0;i!==0&&(n[b++]=i);for(let p=1;p<r;p++)g=t[p],c=g*e,u=B*g,a=u-(u-g),l=g-a,f=l*m-(c-a*d-l*d-a*m),s=o+f,h=s-o,i=o-(s-h)+(f-h),i!==0&&(n[b++]=i),o=c+s,i=s-(o-c),i!==0&&(n[b++]=i);return(o!==0||b===0)&&(n[b++]=o),b}function qe(r,t){let e=t[0];for(let n=1;n<r;n++)e+=t[n];return e}function H(r){return new Float64Array(r)}const Cn=(3+16*gt)*gt,Rn=(2+12*gt)*gt,Bn=(9+64*gt)*gt*gt,Vt=H(4),Xe=H(8),Ye=H(12),We=H(16),pt=H(4);function Pn(r,t,e,n,o,s,i){let c,f,h,u,a,l,d,m,g,b,p,S,v,I,R,N,j,X;const E=r-o,V=e-o,L=t-s,z=n-s;I=E*z,l=B*E,d=l-(l-E),m=E-d,l=B*z,g=l-(l-z),b=z-g,R=m*b-(I-d*g-m*g-d*b),N=L*V,l=B*L,d=l-(l-L),m=L-d,l=B*V,g=l-(l-V),b=V-g,j=m*b-(N-d*g-m*g-d*b),p=R-j,a=R-p,Vt[0]=R-(p+a)+(a-j),S=I+p,a=S-I,v=I-(S-a)+(p-a),p=v-N,a=v-p,Vt[1]=v-(p+a)+(a-N),X=S+p,a=X-S,Vt[2]=S-(X-a)+(p-a),Vt[3]=X;let W=qe(4,Vt),w=Rn*i;if(W>=w||-W>=w||(a=r-E,c=r-(E+a)+(a-o),a=e-V,h=e-(V+a)+(a-o),a=t-L,f=t-(L+a)+(a-s),a=n-z,u=n-(z+a)+(a-s),c===0&&f===0&&h===0&&u===0)||(w=Bn*i+Ve*Math.abs(W),W+=E*u+z*c-(L*h+V*f),W>=w||-W>=w))return W;I=c*z,l=B*c,d=l-(l-c),m=c-d,l=B*z,g=l-(l-z),b=z-g,R=m*b-(I-d*g-m*g-d*b),N=f*V,l=B*f,d=l-(l-f),m=f-d,l=B*V,g=l-(l-V),b=V-g,j=m*b-(N-d*g-m*g-d*b),p=R-j,a=R-p,pt[0]=R-(p+a)+(a-j),S=I+p,a=S-I,v=I-(S-a)+(p-a),p=v-N,a=v-p,pt[1]=v-(p+a)+(a-N),X=S+p,a=X-S,pt[2]=S-(X-a)+(p-a),pt[3]=X;const y=ht(4,Vt,4,pt,Xe);I=E*u,l=B*E,d=l-(l-E),m=E-d,l=B*u,g=l-(l-u),b=u-g,R=m*b-(I-d*g-m*g-d*b),N=L*h,l=B*L,d=l-(l-L),m=L-d,l=B*h,g=l-(l-h),b=h-g,j=m*b-(N-d*g-m*g-d*b),p=R-j,a=R-p,pt[0]=R-(p+a)+(a-j),S=I+p,a=S-I,v=I-(S-a)+(p-a),p=v-N,a=v-p,pt[1]=v-(p+a)+(a-N),X=S+p,a=X-S,pt[2]=S-(X-a)+(p-a),pt[3]=X;const _=ht(y,Xe,4,pt,Ye);I=c*u,l=B*c,d=l-(l-c),m=c-d,l=B*u,g=l-(l-u),b=u-g,R=m*b-(I-d*g-m*g-d*b),N=f*h,l=B*f,d=l-(l-f),m=f-d,l=B*h,g=l-(l-h),b=h-g,j=m*b-(N-d*g-m*g-d*b),p=R-j,a=R-p,pt[0]=R-(p+a)+(a-j),S=I+p,a=S-I,v=I-(S-a)+(p-a),p=v-N,a=v-p,pt[1]=v-(p+a)+(a-N),X=S+p,a=X-S,pt[2]=S-(X-a)+(p-a),pt[3]=X;const x=ht(_,Ye,4,pt,We);return We[x-1]}function Tt(r,t,e,n,o,s){const i=(t-s)*(e-o),c=(r-o)*(n-s),f=i-c,h=Math.abs(i+c);return Math.abs(f)>=Cn*h?f:-Pn(r,t,e,n,o,s,h)}const jn=(10+96*gt)*gt,Un=(4+48*gt)*gt,Dn=(44+576*gt)*gt*gt,Ct=H(4),Rt=H(4),Bt=H(4),Mt=H(4),At=H(4),vt=H(4),mt=H(4),bt=H(4),we=H(8),pe=H(8),me=H(8),be=H(8),ye=H(8),_e=H(8),ie=H(8),oe=H(8),re=H(8),Dt=H(4),$t=H(4),Ft=H(4),P=H(8),q=H(16),st=H(16),it=H(16),Z=H(32),Pt=H(32),ot=H(48),yt=H(64);let qt=H(1152),ke=H(1152);function rt(r,t,e){r=ht(r,qt,t,e,ke);const n=qt;return qt=ke,ke=n,r}function $n(r,t,e,n,o,s,i,c,f){let h,u,a,l,d,m,g,b,p,S,v,I,R,N,j,X,E,V,L,z,W,w,y,_,x,M,O,k,T,U,C,D,$,Y,F;const J=r-i,K=e-i,Q=o-i,tt=t-c,G=n-c,et=s-c;C=K*et,y=B*K,_=y-(y-K),x=K-_,y=B*et,M=y-(y-et),O=et-M,D=x*O-(C-_*M-x*M-_*O),$=Q*G,y=B*Q,_=y-(y-Q),x=Q-_,y=B*G,M=y-(y-G),O=G-M,Y=x*O-($-_*M-x*M-_*O),k=D-Y,w=D-k,Ct[0]=D-(k+w)+(w-Y),T=C+k,w=T-C,U=C-(T-w)+(k-w),k=U-$,w=U-k,Ct[1]=U-(k+w)+(w-$),F=T+k,w=F-T,Ct[2]=T-(F-w)+(k-w),Ct[3]=F,C=Q*tt,y=B*Q,_=y-(y-Q),x=Q-_,y=B*tt,M=y-(y-tt),O=tt-M,D=x*O-(C-_*M-x*M-_*O),$=J*et,y=B*J,_=y-(y-J),x=J-_,y=B*et,M=y-(y-et),O=et-M,Y=x*O-($-_*M-x*M-_*O),k=D-Y,w=D-k,Rt[0]=D-(k+w)+(w-Y),T=C+k,w=T-C,U=C-(T-w)+(k-w),k=U-$,w=U-k,Rt[1]=U-(k+w)+(w-$),F=T+k,w=F-T,Rt[2]=T-(F-w)+(k-w),Rt[3]=F,C=J*G,y=B*J,_=y-(y-J),x=J-_,y=B*G,M=y-(y-G),O=G-M,D=x*O-(C-_*M-x*M-_*O),$=K*tt,y=B*K,_=y-(y-K),x=K-_,y=B*tt,M=y-(y-tt),O=tt-M,Y=x*O-($-_*M-x*M-_*O),k=D-Y,w=D-k,Bt[0]=D-(k+w)+(w-Y),T=C+k,w=T-C,U=C-(T-w)+(k-w),k=U-$,w=U-k,Bt[1]=U-(k+w)+(w-$),F=T+k,w=F-T,Bt[2]=T-(F-w)+(k-w),Bt[3]=F,h=ht(ht(ht(A(A(4,Ct,J,P),P,J,q),q,A(A(4,Ct,tt,P),P,tt,st),st,Z),Z,ht(A(A(4,Rt,K,P),P,K,q),q,A(A(4,Rt,G,P),P,G,st),st,Pt),Pt,yt),yt,ht(A(A(4,Bt,Q,P),P,Q,q),q,A(A(4,Bt,et,P),P,et,st),st,Z),Z,qt);let Nt=qe(h,qt),te=Un*f;if(Nt>=te||-Nt>=te||(w=r-J,u=r-(J+w)+(w-i),w=t-tt,d=t-(tt+w)+(w-c),w=e-K,a=e-(K+w)+(w-i),w=n-G,m=n-(G+w)+(w-c),w=o-Q,l=o-(Q+w)+(w-i),w=s-et,g=s-(et+w)+(w-c),u===0&&a===0&&l===0&&d===0&&m===0&&g===0)||(te=Dn*f+Ve*Math.abs(Nt),Nt+=(J*J+tt*tt)*(K*g+et*a-(G*l+Q*m))+2*(J*u+tt*d)*(K*et-G*Q)+((K*K+G*G)*(Q*d+tt*l-(et*u+J*g))+2*(K*a+G*m)*(Q*tt-et*J))+((Q*Q+et*et)*(J*m+G*u-(tt*a+K*d))+2*(Q*l+et*g)*(J*G-tt*K)),Nt>=te||-Nt>=te))return Nt;if((a!==0||m!==0||l!==0||g!==0)&&(C=J*J,y=B*J,_=y-(y-J),x=J-_,D=x*x-(C-_*_-(_+_)*x),$=tt*tt,y=B*tt,_=y-(y-tt),x=tt-_,Y=x*x-($-_*_-(_+_)*x),k=D+Y,w=k-D,Mt[0]=D-(k-w)+(Y-w),T=C+k,w=T-C,U=C-(T-w)+(k-w),k=U+$,w=k-U,Mt[1]=U-(k-w)+($-w),F=T+k,w=F-T,Mt[2]=T-(F-w)+(k-w),Mt[3]=F),(l!==0||g!==0||u!==0||d!==0)&&(C=K*K,y=B*K,_=y-(y-K),x=K-_,D=x*x-(C-_*_-(_+_)*x),$=G*G,y=B*G,_=y-(y-G),x=G-_,Y=x*x-($-_*_-(_+_)*x),k=D+Y,w=k-D,At[0]=D-(k-w)+(Y-w),T=C+k,w=T-C,U=C-(T-w)+(k-w),k=U+$,w=k-U,At[1]=U-(k-w)+($-w),F=T+k,w=F-T,At[2]=T-(F-w)+(k-w),At[3]=F),(u!==0||d!==0||a!==0||m!==0)&&(C=Q*Q,y=B*Q,_=y-(y-Q),x=Q-_,D=x*x-(C-_*_-(_+_)*x),$=et*et,y=B*et,_=y-(y-et),x=et-_,Y=x*x-($-_*_-(_+_)*x),k=D+Y,w=k-D,vt[0]=D-(k-w)+(Y-w),T=C+k,w=T-C,U=C-(T-w)+(k-w),k=U+$,w=k-U,vt[1]=U-(k-w)+($-w),F=T+k,w=F-T,vt[2]=T-(F-w)+(k-w),vt[3]=F),u!==0&&(b=A(4,Ct,u,we),h=rt(h,_t(A(b,we,2*J,q),q,A(A(4,vt,u,P),P,G,st),st,A(A(4,At,u,P),P,-et,it),it,Z,ot),ot)),d!==0&&(p=A(4,Ct,d,pe),h=rt(h,_t(A(p,pe,2*tt,q),q,A(A(4,At,d,P),P,Q,st),st,A(A(4,vt,d,P),P,-K,it),it,Z,ot),ot)),a!==0&&(S=A(4,Rt,a,me),h=rt(h,_t(A(S,me,2*K,q),q,A(A(4,Mt,a,P),P,et,st),st,A(A(4,vt,a,P),P,-tt,it),it,Z,ot),ot)),m!==0&&(v=A(4,Rt,m,be),h=rt(h,_t(A(v,be,2*G,q),q,A(A(4,vt,m,P),P,J,st),st,A(A(4,Mt,m,P),P,-Q,it),it,Z,ot),ot)),l!==0&&(I=A(4,Bt,l,ye),h=rt(h,_t(A(I,ye,2*Q,q),q,A(A(4,At,l,P),P,tt,st),st,A(A(4,Mt,l,P),P,-G,it),it,Z,ot),ot)),g!==0&&(R=A(4,Bt,g,_e),h=rt(h,_t(A(R,_e,2*et,q),q,A(A(4,Mt,g,P),P,K,st),st,A(A(4,At,g,P),P,-J,it),it,Z,ot),ot)),u!==0||d!==0){if(a!==0||m!==0||l!==0||g!==0?(C=a*et,y=B*a,_=y-(y-a),x=a-_,y=B*et,M=y-(y-et),O=et-M,D=x*O-(C-_*M-x*M-_*O),$=K*g,y=B*K,_=y-(y-K),x=K-_,y=B*g,M=y-(y-g),O=g-M,Y=x*O-($-_*M-x*M-_*O),k=D+Y,w=k-D,mt[0]=D-(k-w)+(Y-w),T=C+k,w=T-C,U=C-(T-w)+(k-w),k=U+$,w=k-U,mt[1]=U-(k-w)+($-w),F=T+k,w=F-T,mt[2]=T-(F-w)+(k-w),mt[3]=F,C=l*-G,y=B*l,_=y-(y-l),x=l-_,y=B*-G,M=y-(y- -G),O=-G-M,D=x*O-(C-_*M-x*M-_*O),$=Q*-m,y=B*Q,_=y-(y-Q),x=Q-_,y=B*-m,M=y-(y- -m),O=-m-M,Y=x*O-($-_*M-x*M-_*O),k=D+Y,w=k-D,bt[0]=D-(k-w)+(Y-w),T=C+k,w=T-C,U=C-(T-w)+(k-w),k=U+$,w=k-U,bt[1]=U-(k-w)+($-w),F=T+k,w=F-T,bt[2]=T-(F-w)+(k-w),bt[3]=F,j=ht(4,mt,4,bt,oe),C=a*g,y=B*a,_=y-(y-a),x=a-_,y=B*g,M=y-(y-g),O=g-M,D=x*O-(C-_*M-x*M-_*O),$=l*m,y=B*l,_=y-(y-l),x=l-_,y=B*m,M=y-(y-m),O=m-M,Y=x*O-($-_*M-x*M-_*O),k=D-Y,w=D-k,$t[0]=D-(k+w)+(w-Y),T=C+k,w=T-C,U=C-(T-w)+(k-w),k=U-$,w=U-k,$t[1]=U-(k+w)+(w-$),F=T+k,w=F-T,$t[2]=T-(F-w)+(k-w),$t[3]=F,V=4):(oe[0]=0,j=1,$t[0]=0,V=1),u!==0){const lt=A(j,oe,u,it);h=rt(h,ht(A(b,we,u,q),q,A(lt,it,2*J,Z),Z,ot),ot);const ut=A(V,$t,u,P);h=rt(h,_t(A(ut,P,2*J,q),q,A(ut,P,u,st),st,A(lt,it,u,Z),Z,Pt,yt),yt),m!==0&&(h=rt(h,A(A(4,vt,u,P),P,m,q),q)),g!==0&&(h=rt(h,A(A(4,At,-u,P),P,g,q),q))}if(d!==0){const lt=A(j,oe,d,it);h=rt(h,ht(A(p,pe,d,q),q,A(lt,it,2*tt,Z),Z,ot),ot);const ut=A(V,$t,d,P);h=rt(h,_t(A(ut,P,2*tt,q),q,A(ut,P,d,st),st,A(lt,it,d,Z),Z,Pt,yt),yt)}}if(a!==0||m!==0){if(l!==0||g!==0||u!==0||d!==0?(C=l*tt,y=B*l,_=y-(y-l),x=l-_,y=B*tt,M=y-(y-tt),O=tt-M,D=x*O-(C-_*M-x*M-_*O),$=Q*d,y=B*Q,_=y-(y-Q),x=Q-_,y=B*d,M=y-(y-d),O=d-M,Y=x*O-($-_*M-x*M-_*O),k=D+Y,w=k-D,mt[0]=D-(k-w)+(Y-w),T=C+k,w=T-C,U=C-(T-w)+(k-w),k=U+$,w=k-U,mt[1]=U-(k-w)+($-w),F=T+k,w=F-T,mt[2]=T-(F-w)+(k-w),mt[3]=F,z=-et,W=-g,C=u*z,y=B*u,_=y-(y-u),x=u-_,y=B*z,M=y-(y-z),O=z-M,D=x*O-(C-_*M-x*M-_*O),$=J*W,y=B*J,_=y-(y-J),x=J-_,y=B*W,M=y-(y-W),O=W-M,Y=x*O-($-_*M-x*M-_*O),k=D+Y,w=k-D,bt[0]=D-(k-w)+(Y-w),T=C+k,w=T-C,U=C-(T-w)+(k-w),k=U+$,w=k-U,bt[1]=U-(k-w)+($-w),F=T+k,w=F-T,bt[2]=T-(F-w)+(k-w),bt[3]=F,X=ht(4,mt,4,bt,re),C=l*d,y=B*l,_=y-(y-l),x=l-_,y=B*d,M=y-(y-d),O=d-M,D=x*O-(C-_*M-x*M-_*O),$=u*g,y=B*u,_=y-(y-u),x=u-_,y=B*g,M=y-(y-g),O=g-M,Y=x*O-($-_*M-x*M-_*O),k=D-Y,w=D-k,Ft[0]=D-(k+w)+(w-Y),T=C+k,w=T-C,U=C-(T-w)+(k-w),k=U-$,w=U-k,Ft[1]=U-(k+w)+(w-$),F=T+k,w=F-T,Ft[2]=T-(F-w)+(k-w),Ft[3]=F,L=4):(re[0]=0,X=1,Ft[0]=0,L=1),a!==0){const lt=A(X,re,a,it);h=rt(h,ht(A(S,me,a,q),q,A(lt,it,2*K,Z),Z,ot),ot);const ut=A(L,Ft,a,P);h=rt(h,_t(A(ut,P,2*K,q),q,A(ut,P,a,st),st,A(lt,it,a,Z),Z,Pt,yt),yt),g!==0&&(h=rt(h,A(A(4,Mt,a,P),P,g,q),q)),d!==0&&(h=rt(h,A(A(4,vt,-a,P),P,d,q),q))}if(m!==0){const lt=A(X,re,m,it);h=rt(h,ht(A(v,be,m,q),q,A(lt,it,2*G,Z),Z,ot),ot);const ut=A(L,Ft,m,P);h=rt(h,_t(A(ut,P,2*G,q),q,A(ut,P,m,st),st,A(lt,it,m,Z),Z,Pt,yt),yt)}}if(l!==0||g!==0){if(u!==0||d!==0||a!==0||m!==0?(C=u*G,y=B*u,_=y-(y-u),x=u-_,y=B*G,M=y-(y-G),O=G-M,D=x*O-(C-_*M-x*M-_*O),$=J*m,y=B*J,_=y-(y-J),x=J-_,y=B*m,M=y-(y-m),O=m-M,Y=x*O-($-_*M-x*M-_*O),k=D+Y,w=k-D,mt[0]=D-(k-w)+(Y-w),T=C+k,w=T-C,U=C-(T-w)+(k-w),k=U+$,w=k-U,mt[1]=U-(k-w)+($-w),F=T+k,w=F-T,mt[2]=T-(F-w)+(k-w),mt[3]=F,z=-tt,W=-d,C=a*z,y=B*a,_=y-(y-a),x=a-_,y=B*z,M=y-(y-z),O=z-M,D=x*O-(C-_*M-x*M-_*O),$=K*W,y=B*K,_=y-(y-K),x=K-_,y=B*W,M=y-(y-W),O=W-M,Y=x*O-($-_*M-x*M-_*O),k=D+Y,w=k-D,bt[0]=D-(k-w)+(Y-w),T=C+k,w=T-C,U=C-(T-w)+(k-w),k=U+$,w=k-U,bt[1]=U-(k-w)+($-w),F=T+k,w=F-T,bt[2]=T-(F-w)+(k-w),bt[3]=F,N=ht(4,mt,4,bt,ie),C=u*m,y=B*u,_=y-(y-u),x=u-_,y=B*m,M=y-(y-m),O=m-M,D=x*O-(C-_*M-x*M-_*O),$=a*d,y=B*a,_=y-(y-a),x=a-_,y=B*d,M=y-(y-d),O=d-M,Y=x*O-($-_*M-x*M-_*O),k=D-Y,w=D-k,Dt[0]=D-(k+w)+(w-Y),T=C+k,w=T-C,U=C-(T-w)+(k-w),k=U-$,w=U-k,Dt[1]=U-(k+w)+(w-$),F=T+k,w=F-T,Dt[2]=T-(F-w)+(k-w),Dt[3]=F,E=4):(ie[0]=0,N=1,Dt[0]=0,E=1),l!==0){const lt=A(N,ie,l,it);h=rt(h,ht(A(I,ye,l,q),q,A(lt,it,2*Q,Z),Z,ot),ot);const ut=A(E,Dt,l,P);h=rt(h,_t(A(ut,P,2*Q,q),q,A(ut,P,l,st),st,A(lt,it,l,Z),Z,Pt,yt),yt),d!==0&&(h=rt(h,A(A(4,At,l,P),P,d,q),q)),m!==0&&(h=rt(h,A(A(4,Mt,-l,P),P,m,q),q))}if(g!==0){const lt=A(N,ie,g,it);h=rt(h,ht(A(R,_e,g,q),q,A(lt,it,2*et,Z),Z,ot),ot);const ut=A(E,Dt,g,P);h=rt(h,_t(A(ut,P,2*et,q),q,A(ut,P,g,st),st,A(lt,it,g,Z),Z,Pt,yt),yt)}}return qt[h-1]}function Fn(r,t,e,n,o,s,i,c){const f=r-i,h=e-i,u=o-i,a=t-c,l=n-c,d=s-c,m=h*d,g=u*l,b=f*f+a*a,p=u*a,S=f*d,v=h*h+l*l,I=f*l,R=h*a,N=u*u+d*d,j=b*(m-g)+v*(p-S)+N*(I-R),X=(Math.abs(m)+Math.abs(g))*b+(Math.abs(p)+Math.abs(S))*v+(Math.abs(I)+Math.abs(R))*N,E=jn*X;return j>E||-j>E?j:$n(r,t,e,n,o,s,i,c,X)}const Je=Math.pow(2,-52),ce=new Uint32Array(512);class xe{static from(t,e=Xn,n=Yn){const o=t.length,s=new Float64Array(o*2);for(let i=0;i<o;i++){const c=t[i];s[2*i]=e(c),s[2*i+1]=n(c)}return new xe(s)}constructor(t){const e=t.length>>1;if(e>0&&typeof t[0]!="number")throw new Error("Expected coords to contain numbers.");this.coords=t;const n=Math.max(2*e-5,0);this._triangles=new Uint32Array(n*3),this._halfedges=new Int32Array(n*3),this._hashSize=Math.ceil(Math.sqrt(e)),this._hullPrev=new Uint32Array(e),this._hullNext=new Uint32Array(e),this._hullTri=new Uint32Array(e),this._hullHash=new Int32Array(this._hashSize),this._ids=new Uint32Array(e),this._dists=new Float64Array(e),this.update()}update(){const{coords:t,_hullPrev:e,_hullNext:n,_hullTri:o,_hullHash:s}=this,i=t.length>>1;let c=1/0,f=1/0,h=-1/0,u=-1/0;for(let E=0;E<i;E++){const V=t[2*E],L=t[2*E+1];V<c&&(c=V),L<f&&(f=L),V>h&&(h=V),L>u&&(u=L),this._ids[E]=E}const a=(c+h)/2,l=(f+u)/2;let d,m,g;for(let E=0,V=1/0;E<i;E++){const L=Se(a,l,t[2*E],t[2*E+1]);L<V&&(d=E,V=L)}const b=t[2*d],p=t[2*d+1];for(let E=0,V=1/0;E<i;E++){if(E===d)continue;const L=Se(b,p,t[2*E],t[2*E+1]);L<V&&L>0&&(m=E,V=L)}let S=t[2*m],v=t[2*m+1],I=1/0;for(let E=0;E<i;E++){if(E===d||E===m)continue;const V=Vn(b,p,S,v,t[2*E],t[2*E+1]);V<I&&(g=E,I=V)}let R=t[2*g],N=t[2*g+1];if(I===1/0){for(let L=0;L<i;L++)this._dists[L]=t[2*L]-t[0]||t[2*L+1]-t[1];Xt(this._ids,this._dists,0,i-1);const E=new Uint32Array(i);let V=0;for(let L=0,z=-1/0;L<i;L++){const W=this._ids[L],w=this._dists[W];w>z&&(E[V++]=W,z=w)}this.hull=E.subarray(0,V),this.triangles=new Uint32Array(0),this.halfedges=new Uint32Array(0);return}if(Tt(b,p,S,v,R,N)<0){const E=m,V=S,L=v;m=g,S=R,v=N,g=E,R=V,N=L}const j=qn(b,p,S,v,R,N);this._cx=j.x,this._cy=j.y;for(let E=0;E<i;E++)this._dists[E]=Se(t[2*E],t[2*E+1],j.x,j.y);Xt(this._ids,this._dists,0,i-1),this._hullStart=d;let X=3;n[d]=e[g]=m,n[m]=e[d]=g,n[g]=e[m]=d,o[d]=0,o[m]=1,o[g]=2,s.fill(-1),s[this._hashKey(b,p)]=d,s[this._hashKey(S,v)]=m,s[this._hashKey(R,N)]=g,this.trianglesLen=0,this._addTriangle(d,m,g,-1,-1,-1);for(let E=0,V,L;E<this._ids.length;E++){const z=this._ids[E],W=t[2*z],w=t[2*z+1];if(E>0&&Math.abs(W-V)<=Je&&Math.abs(w-L)<=Je||(V=W,L=w,z===d||z===m||z===g))continue;let y=0;for(let k=0,T=this._hashKey(W,w);k<this._hashSize&&(y=s[(T+k)%this._hashSize],!(y!==-1&&y!==n[y]));k++);y=e[y];let _=y,x;for(;x=n[_],Tt(W,w,t[2*_],t[2*_+1],t[2*x],t[2*x+1])>=0;)if(_=x,_===y){_=-1;break}if(_===-1)continue;let M=this._addTriangle(_,z,n[_],-1,-1,o[_]);o[z]=this._legalize(M+2),o[_]=M,X++;let O=n[_];for(;x=n[O],Tt(W,w,t[2*O],t[2*O+1],t[2*x],t[2*x+1])<0;)M=this._addTriangle(O,z,x,o[z],-1,o[O]),o[z]=this._legalize(M+2),n[O]=O,X--,O=x;if(_===y)for(;x=e[_],Tt(W,w,t[2*x],t[2*x+1],t[2*_],t[2*_+1])<0;)M=this._addTriangle(x,z,_,-1,o[_],o[x]),this._legalize(M+2),o[x]=M,n[_]=_,X--,_=x;this._hullStart=e[z]=_,n[_]=e[O]=z,n[z]=O,s[this._hashKey(W,w)]=z,s[this._hashKey(t[2*_],t[2*_+1])]=_}this.hull=new Uint32Array(X);for(let E=0,V=this._hullStart;E<X;E++)this.hull[E]=V,V=n[V];this.triangles=this._triangles.subarray(0,this.trianglesLen),this.halfedges=this._halfedges.subarray(0,this.trianglesLen)}_hashKey(t,e){return Math.floor(Ln(t-this._cx,e-this._cy)*this._hashSize)%this._hashSize}_legalize(t){const{_triangles:e,_halfedges:n,coords:o}=this;let s=0,i=0;for(;;){const c=n[t],f=t-t%3;if(i=f+(t+2)%3,c===-1){if(s===0)break;t=ce[--s];continue}const h=c-c%3,u=f+(t+1)%3,a=h+(c+2)%3,l=e[i],d=e[t],m=e[u],g=e[a];if(zn(o[2*l],o[2*l+1],o[2*d],o[2*d+1],o[2*m],o[2*m+1],o[2*g],o[2*g+1])){e[t]=g,e[c]=l;const p=n[a];if(p===-1){let v=this._hullStart;do{if(this._hullTri[v]===a){this._hullTri[v]=t;break}v=this._hullPrev[v]}while(v!==this._hullStart)}this._link(t,p),this._link(c,n[i]),this._link(i,a);const S=h+(c+1)%3;s<ce.length&&(ce[s++]=S)}else{if(s===0)break;t=ce[--s]}}return i}_link(t,e){this._halfedges[t]=e,e!==-1&&(this._halfedges[e]=t)}_addTriangle(t,e,n,o,s,i){const c=this.trianglesLen;return this._triangles[c]=t,this._triangles[c+1]=e,this._triangles[c+2]=n,this._link(c,o),this._link(c+1,s),this._link(c+2,i),this.trianglesLen+=3,c}}function Ln(r,t){const e=r/(Math.abs(r)+Math.abs(t));return(t>0?3-e:1+e)/4}function Se(r,t,e,n){const o=r-e,s=t-n;return o*o+s*s}function zn(r,t,e,n,o,s,i,c){const f=r-i,h=t-c,u=e-i,a=n-c,l=o-i,d=s-c,m=f*f+h*h,g=u*u+a*a,b=l*l+d*d;return f*(a*b-g*d)-h*(u*b-g*l)+m*(u*d-a*l)<0}function Vn(r,t,e,n,o,s){const i=e-r,c=n-t,f=o-r,h=s-t,u=i*i+c*c,a=f*f+h*h,l=.5/(i*h-c*f),d=(h*u-c*a)*l,m=(i*a-f*u)*l;return d*d+m*m}function qn(r,t,e,n,o,s){const i=e-r,c=n-t,f=o-r,h=s-t,u=i*i+c*c,a=f*f+h*h,l=.5/(i*h-c*f),d=r+(h*u-c*a)*l,m=t+(i*a-f*u)*l;return{x:d,y:m}}function Xt(r,t,e,n){if(n-e<=20)for(let o=e+1;o<=n;o++){const s=r[o],i=t[s];let c=o-1;for(;c>=e&&t[r[c]]>i;)r[c+1]=r[c--];r[c+1]=s}else{const o=e+n>>1;let s=e+1,i=n;Kt(r,o,s),t[r[e]]>t[r[n]]&&Kt(r,e,n),t[r[s]]>t[r[n]]&&Kt(r,s,n),t[r[e]]>t[r[s]]&&Kt(r,e,s);const c=r[s],f=t[c];for(;;){do s++;while(t[r[s]]<f);do i--;while(t[r[i]]>f);if(i<s)break;Kt(r,s,i)}r[e+1]=r[i],r[i]=c,n-s+1>=i-e?(Xt(r,t,s,n),Xt(r,t,e,i-1)):(Xt(r,t,e,i-1),Xt(r,t,s,n))}}function Kt(r,t,e){const n=r[t];r[t]=r[e],r[e]=n}function Xn(r){return r[0]}function Yn(r){return r[1]}class Wn{bs;width;constructor(t,e){this.width=t,this.bs=e}add(t){const e=Math.floor(t/this.width),n=t%this.width;return this.bs[e]|=1<<n,this}delete(t){const e=Math.floor(t/this.width),n=t%this.width;return this.bs[e]&=~(1<<n),this}set(t,e){const n=Math.floor(t/this.width),s=1<<t%this.width;return this.bs[n]^=(-Number(e)^this.bs[n])&s,e}has(t){const e=Math.floor(t/this.width),n=t%this.width;return(this.bs[e]&1<<n)!==0}forEach(t){const e=this.bs.length;for(let n=0;n<e;n++){let o=0;for(;this.bs[n]&&o<this.width;)this.bs[n]&1<<o&&t(n*this.width+o),o++}return this}}class Ke extends Wn{constructor(t){super(8,new Uint8Array(Math.ceil(t/8)).fill(0))}}function Lt(r){return r%3===2?r-2:r+1}function It(r){return r%3===0?r+2:r-1}function Qe(r,t,e,n,o,s,i,c){const f=Tt(r,t,o,s,i,c),h=Tt(e,n,o,s,i,c);if(f>0&&h>0||f<0&&h<0)return!1;const u=Tt(o,s,r,t,e,n),a=Tt(i,c,r,t,e,n);return u>0&&a>0||u<0&&a<0?!1:f===0&&h===0&&u===0&&a===0?!(Math.max(o,i)<Math.min(r,e)||Math.max(r,e)<Math.min(o,i)||Math.max(s,c)<Math.min(t,n)||Math.max(t,n)<Math.min(s,c)):!0}class Jn{del;constructor(t){this.del=t}}class Kn extends Jn{vertMap;flips;consd;constructor(t,e){if(!t||typeof t!="object"||!t.triangles||!t.halfedges||!t.coords)throw new Error("Expected an object with Delaunator output");if(t.triangles.length%3||t.halfedges.length!==t.triangles.length||t.coords.length%2)throw new Error("Delaunator output appears inconsistent");if(t.triangles.length<3)throw new Error("No edges in triangulation");super(t);const n=2**32-1,o=t.coords.length>>1,s=t.triangles.length;this.vertMap=new Uint32Array(o).fill(n),this.flips=new Ke(s),this.consd=new Ke(s);for(let i=0;i<s;i++){const c=t.triangles[i];this.vertMap[c]===n&&this.updateVert(i)}e&&this.constrainAll(e)}constrainOne(t,e){const{triangles:n,halfedges:o}=this.del,s=this.vertMap[t];let i=s;do{const h=n[i],u=Lt(i);if(h===e)return this.protect(i);const a=It(i),l=n[a];if(l===e)return this.protect(u),u;if(this.intersectSegments(t,e,l,h)){i=a;break}i=o[u]}while(i!==-1&&i!==s);let c=i,f=-1;for(;i!==-1;){const h=o[i],u=It(i),a=It(h),l=Lt(h);if(h===-1)throw new Error("Constraining edge exited the hull");if(this.consd.has(i))throw new Error("Edge intersects already constrained edge");if(this.isCollinear(t,e,n[i])||this.isCollinear(t,e,n[h]))throw new Error("Constraining edge intersects point");if(!this.intersectSegments(n[i],n[h],n[u],n[a])){if(f===-1&&(f=i),n[a]===e){if(i===f)throw new Error("Infinite loop: non-convex quadrilateral");i=f,f=-1;continue}if(this.intersectSegments(t,e,n[a],n[h]))i=a;else if(this.intersectSegments(t,e,n[l],n[a]))i=l;else if(f===i)throw new Error("Infinite loop: no further intersect after non-convex");continue}if(this.flipDiagonal(i),this.intersectSegments(t,e,n[u],n[a])&&(f===-1&&(f=u),f===u))throw new Error("Infinite loop: flipped diagonal still intersects");n[a]===e?(c=a,i=f,f=-1):this.intersectSegments(t,e,n[l],n[a])&&(i=l)}return this.protect(c),this.delaunify(!0),this.findEdge(t,e)}delaunify(t=!1){const{halfedges:e}=this.del,n=this.flips,o=this.consd,s=e.length;let i;do{i=0;for(let c=0;c<s;c++){if(o.has(c))continue;n.delete(c);const f=e[c];f!==-1&&(n.delete(f),this.isDelaunay(c)||(this.flipDiagonal(c),i++))}}while(t&&i>0);return this}constrainAll(t){const e=t.length;for(let n=0;n<e;n++){const o=t[n];this.constrainOne(o[0],o[1])}return this}isConstrained(t){return this.consd.has(t)}findEdge(t,e){const n=this.vertMap[e],{triangles:o,halfedges:s}=this.del;let i=n,c=-1;do{if(o[i]===t)return i;c=Lt(i),i=s[c]}while(i!==-1&&i!==n);return o[Lt(c)]===t?-c:1/0}protect(t){const e=this.del.halfedges[t],n=this.flips,o=this.consd;return n.delete(t),o.add(t),e!==-1?(n.delete(e),o.add(e),e):-t}markFlip(t){const e=this.del.halfedges,n=this.flips;if(this.consd.has(t))return!1;const s=e[t];return s!==-1&&(n.add(t),n.add(s)),!0}flipDiagonal(t){const{triangles:e,halfedges:n}=this.del,o=this.flips,s=this.consd,i=n[t],c=It(t),f=Lt(t),h=It(i),u=Lt(i),a=n[c],l=n[h];if(s.has(t))throw new Error("Trying to flip a constrained edge");return e[t]=e[h],n[t]=l,o.set(t,o.has(h))||s.set(t,s.has(h)),l!==-1&&(n[l]=t),n[c]=h,e[i]=e[c],n[i]=a,o.set(i,o.has(c))||s.set(i,s.has(c)),a!==-1&&(n[a]=i),n[h]=c,this.markFlip(t),this.markFlip(f),this.markFlip(i),this.markFlip(u),o.add(c),s.delete(c),o.add(h),s.delete(h),this.updateVert(t),this.updateVert(f),this.updateVert(i),this.updateVert(u),c}isCollinear(t,e,n){const o=this.del.coords;return Tt(o[t*2],o[t*2+1],o[e*2],o[e*2+1],o[n*2],o[n*2+1])===0}inCircle(t,e,n,o){const s=this.del.coords;return Fn(s[t*2],s[t*2+1],s[e*2],s[e*2+1],s[n*2],s[n*2+1],s[o*2],s[o*2+1])<0}isDelaunay(t){const{triangles:e,halfedges:n}=this.del,o=n[t];if(o===-1)return!0;const s=e[It(t)],i=e[t],c=e[Lt(t)],f=e[It(o)];return!this.inCircle(s,i,c,f)}updateVert(t){const{triangles:e,halfedges:n}=this.del,o=this.vertMap,s=e[t];let i=It(t),c=n[i];for(;c!==-1&&c!==t;)i=It(c),c=n[i];return o[s]=i,i}intersectSegments(t,e,n,o){const s=this.del.coords;return t===n||t===o||e===n||e===o?!1:Qe(s[t*2],s[t*2+1],s[e*2],s[e*2+1],s[n*2],s[n*2+1],s[o*2],s[o*2+1])}static intersectSegments=Qe}function Qt(r,t,e){if(t||(t=[]),typeof r!="object"||r.type!=="FeatureCollection")throw"Argument points must be FeatureCollection";if(!Array.isArray(t))throw"Argument points must be Array of Array";const n=r.features.map(f=>f.geometry.coordinates),o=xe.from(n);let s;const i=[];o.triangles.length!==0&&t.length!==0&&(s=new Kn(o),s.constrainAll(t));for(let f=0;f<o.triangles.length;f+=3)i.push([o.triangles[f],o.triangles[f+1],o.triangles[f+2]]);const c=["a","b","c"];return at.featureCollection(i.map(f=>{const h={},u=f.map((a,l)=>{const d=r.features[a],m=d.geometry.coordinates,g=[m[0],m[1]];return m.length===3?g[2]=m[2]:h[c[l]]=d.properties[e],g});return u[3]=u[0],at.polygon([u],h)}))}function Ge(r,t,e,n,o,s){return Object.keys(r).reduce((i,c)=>{const f=r[c],h=f.forw,u=f.bakw,a={forw:[h[0]-t.forw[0],h[1]-t.forw[1]],bakw:[u[0]-t.bakw[0],u[1]-t.bakw[1]]},l=a.forw[0]===0?1/0:((a.forw[0]<0?e:n)-t.forw[0])/a.forw[0],d=a.forw[1]===0?1/0:((a.forw[1]<0?o:s)-t.forw[1])/a.forw[1];if(Math.abs(l)/Math.abs(d)<1.1){const m={forw:[a.forw[0]*l+t.forw[0],a.forw[1]*l+t.forw[1]],bakw:[a.bakw[0]*l+t.bakw[0],a.bakw[1]*l+t.bakw[1]]};a.forw[0]<0?i[3].push(m):i[1].push(m)}if(Math.abs(d)/Math.abs(l)<1.1){const m={forw:[a.forw[0]*d+t.forw[0],a.forw[1]*d+t.forw[1]],bakw:[a.bakw[0]*d+t.bakw[0],a.bakw[1]*d+t.bakw[1]]};a.forw[1]<0?i[0].push(m):i[2].push(m)}return i},[[],[],[],[]])}function Qn(r,t){const e=[[],[],[],[]],n=[];return Object.keys(r).forEach(o=>{const s=r[o],i=s.forw,c=s.bakw,f=[i[0]-t.forw[0],i[1]-t.forw[1]],h=[c[0]-t.bakw[0],t.bakw[1]-c[1]],u={forw:f,bakw:h};if(n.push(u),f[0]===0||f[1]===0)return;let a=0;f[0]>0&&(a+=1),f[1]>0&&(a+=2),e[a].push(u)}),{perQuad:e,aggregate:n}}function Gn(r){let t=1/0,e=0,n=0;return r.forEach(o=>{const{forw:s,bakw:i}=o,c=Math.hypot(s[0],s[1]),f=Math.hypot(i[0],i[1]);if(f===0)return;const h=c/f,u=Math.atan2(s[0],s[1])-Math.atan2(i[0],i[1]);t=Math.min(t,h),e+=Math.cos(u),n+=Math.sin(u)}),isFinite(t)?[t,Math.atan2(n,e)]:[1,0]}function He(r,t,e){const{perQuad:n,aggregate:o}=Qn(r,t),s=n.every(f=>f.length>0);let i;e==="birdeye"&&s?i=n:e==="birdeye"?i=[o]:s?i=n:i=[o];const c=i.map(f=>Gn(f));return c.length===1?[c[0],c[0],c[0],c[0]]:c}function Hn(r,t,e){const n=[1,1,1,1];for(let o=0;o<4;o++){const s=(o+1)%4,i=at.lineString([r[o].bakw,r[s].bakw]);t[o].map(c=>{const f=at.lineString([e.bakw,c.bakw]),h=dn(i,f);if(h.features.length>0&&h.features[0].geometry){const u=h.features[0],a=Math.sqrt(Math.pow(c.bakw[0]-e.bakw[0],2)+Math.pow(c.bakw[1]-e.bakw[1],2)),l=Math.sqrt(Math.pow(u.geometry.coordinates[0]-e.bakw[0],2)+Math.pow(u.geometry.coordinates[1]-e.bakw[1],2)),d=a/l;d>n[o]&&(n[o]=d),d>n[s]&&(n[s]=d)}})}r.forEach((o,s)=>{const i=n[s],c=[(o.bakw[0]-e.bakw[0])*i+e.bakw[0],(o.bakw[1]-e.bakw[1])*i+e.bakw[1]];o.bakw=c})}function Ze(r,t,e,n){const o=r.map((i,c)=>{const f=t[c],h=[f[0]-e.forw[0],f[1]-e.forw[1]],a=Math.sqrt(Math.pow(h[0],2)+Math.pow(h[1],2))/i[0],l=Math.atan2(h[0],h[1])-i[1],d=[e.bakw[0]+a*Math.sin(l),e.bakw[1]-a*Math.cos(l)];return{forw:f,bakw:d}}),s=o[2];return o[2]=o[3],o[3]=s,Hn(o,n,e),o}function Zn(r){const{convexBuf:t,centroid:e,bbox:n,minx:o,maxx:s,miny:i,maxy:c}=r,f=Ge(t,e,o,s,i,c),h=He(t,e,"plain");return Ze(h,n,e,f)}function ts(r){const{convexBuf:t,centroid:e,bbox:n,minx:o,maxx:s,miny:i,maxy:c}=r,f=Ge(t,e,o,s,i,c),h=He(t,e,"birdeye");return Ze(h,n,e,f)}function tn(r){const e=new es(r).findSegmentIntersections();return cn(e).reduce((n,o,s,i)=>Array.isArray(n)||(n||(n={}),n[`${o.x}:${o.y}`]=o,s!=i.length-1)?n:Object.keys(n).map(c=>at.point([n[c].x,n[c].y])),{})}class es{_xx;_yy;_ii;_nn;_zz;_zlimit=0;_bb;_allBounds;_arcIter;_filteredArcIter;buf;constructor(t){this.initArcs(t)}initArcs(t){const e=[],n=[],o=t.map(s=>{const i=s?s.length:0;for(let c=0;c<i;c++)e.push(s[c][0]),n.push(s[c][1]);return i});this.initXYData(o,e,n)}initXYData(t,e,n){const o=t.length;this._xx=new Float64Array(e),this._yy=new Float64Array(n),this._nn=new Uint32Array(t),this._zz=null,this._zlimit=0,this._filteredArcIter=null,this._ii=new Uint32Array(o);let s=0;for(let i=0;i<o;i++)this._ii[i]=s,s+=t[i];(s!=this._xx.length||this._xx.length!=this._yy.length)&&Me("ArcCollection#initXYData() Counting error"),this.initBounds(),this._arcIter=new ks(this._xx,this._yy)}initBounds(){const t=this.calcArcBounds_(this._xx,this._yy,this._nn);this._bb=t.bb,this._allBounds=t.bounds}calcArcBounds_(t,e,n){const o=n.length,s=new Float64Array(o*4),i=new fe;let c=0,f,h,u;for(let a=0;a<o;a++)f=n[a],f>0&&(h=a*4,u=xs(t,e,c,f),s[h++]=u[0],s[h++]=u[1],s[h++]=u[2],s[h]=u[3],c+=f,i.mergeBounds(u));return{bb:s,bounds:i}}getBounds(){return this._allBounds.clone()}forEachSegment(t){let e=0;for(let n=0,o=this.size();n<o;n++)e+=this.forEachArcSegment(n,t);return e}size(){return this._ii&&this._ii.length||0}forEachArcSegment(t,e){const n=t>=0,o=n?t:~t,s=this.getRetainedInterval(),i=this._nn[o],c=n?1:-1;let f=n?this._ii[o]:this._ii[o]+i-1,h=f,u=0;for(let a=1;a<i;a++)h+=c,(s===0||this._zz[h]>=s)&&(e(f,h,this._xx,this._yy),f=h,u++);return u}getRetainedInterval(){return this._zlimit}getVertexData(){return{xx:this._xx,yy:this._yy,zz:this._zz,bb:this._bb,nn:this._nn,ii:this._ii}}getUint32Array(t){const e=t*4;return(!this.buf||this.buf.byteLength<e)&&(this.buf=new ArrayBuffer(e)),new Uint32Array(this.buf,0,t)}getAvgSegment2(){let t=0,e=0;const n=this.forEachSegment((o,s,i,c)=>{t+=Math.abs(i[o]-i[s]),e+=Math.abs(c[o]-c[s])});return[t/n||0,e/n||0]}calcSegmentIntersectionStripeCount(){const t=this.getBounds().height(),e=this.getAvgSegment2()[1];let n=1;return e>0&&t>0&&(n=Math.ceil(t/e/20)),n||1}findSegmentIntersections(){const t=this.getBounds(),e=t.ymin,n=t.ymax-e,o=this.calcSegmentIntersectionStripeCount(),s=new Uint32Array(o),i=o>1?g=>Math.floor((o-1)*(g-e)/n):()=>0;let c,f;this.forEachSegment((g,b,p,S)=>{let v=i(S[g]);const I=i(S[b]);for(;s[v]=s[v]+2,v!=I;)v+=I>v?1:-1});const h=this.getUint32Array(is(s));let u=0;const a=[];os(s,g=>{const b=u;u+=g,a.push(h.subarray(b,u))}),rs(s,0),this.forEachSegment((g,b,p,S)=>{let v=i(S[g]);const I=i(S[b]);let R,N;for(;R=s[v],s[v]=R+2,N=a[v],N[R]=g,N[R+1]=b,v!=I;)v+=I>v?1:-1});const l=this.getVertexData(),d=[];let m;for(c=0;c<o;c++)for(m=cs(a[c],l.xx,l.yy),f=0;f<m.length;f++)d.push(m[f]);return cn(d)}}function Me(...r){const t=r.join(" ");throw new Error(t)}function Ae(r){return r?ss(r)?!0:ns(r)?!1:r.length===0?!0:r.length>0:!1}function ns(r){return r!=null&&r.toString===String.prototype.toString}function ss(r){return Array.isArray(r)}function is(r,t){Ae(r)||Me("utils.sum() expects an array, received:",r);let e=0,n;for(let o=0,s=r.length;o<s;o++)n=r[o],n&&(e+=n);return e}function os(r,t,e){if(!Ae(r))throw new Error(`#forEach() takes an array-like argument. ${r}`);for(let n=0,o=r.length;n<o;n++)t.call(e,r[n],n)}function rs(r,t){for(let e=0,n=r.length;e<n;e++)r[e]=t;return r}function cs(r,t,e){const n=r.length-2,o=[];let s,i,c,f,h,u,a,l,d,m,g,b,p,S,v,I,R;for(ms(t,r),I=0;I<n;){for(s=r[I],i=r[I+1],h=t[s],u=t[i],d=e[s],m=e[i],R=I;R<n&&(R+=2,c=r[R],a=t[c],!(u<a));){if(g=e[c],f=r[R+1],l=t[f],b=e[f],d>=g){if(d>b&&m>g&&m>b)continue}else if(d<b&&m<g&&m<b)continue;s==c||s==f||i==c||i==f||(p=as(h,d,u,m,a,g,l,b),p&&(S=[s,i],v=[c,f],o.push(on(p,S,v,t,e)),p.length==4&&o.push(on(p.slice(2),S,v,t,e))))}I+=2}return o}function as(r,t,e,n,o,s,i,c){const f=hs(r,t,e,n,o,s,i,c);let h=null;return f&&(h=fs(r,t,e,n,o,s,i,c),h?ps(r,t,e,n,o,s,i,c)&&(h=null):h=ws(r,t,e,n,o,s,i,c)),h}function hs(r,t,e,n,o,s,i,c){return Gt(r,t,e,n,o,s)*Gt(r,t,e,n,i,c)<=0&&Gt(o,s,i,c,r,t)*Gt(o,s,i,c,e,n)<=0}function Gt(r,t,e,n,o,s){return en(r-o,t-s,e-o,n-s)}function en(r,t,e,n){return r*n-t*e}function fs(r,t,e,n,o,s,i,c){let f=ae(r,t,e,n,o,s,i,c),h;return f&&(h=us(f[0],f[1],r,t,e,n,o,s,i,c),h==1?f=ae(e,n,r,t,o,s,i,c):h==2?f=ae(o,s,i,c,r,t,e,n):h==3&&(f=ae(i,c,o,s,r,t,e,n))),f&&gs(f,r,t,e,n,o,s,i,c),f}function ae(r,t,e,n,o,s,i,c){const f=en(e-r,n-t,i-o,c-s),h=1e-18;let u;if(f===0)return null;const a=Gt(o,s,i,c,r,t)/f;return f<=h&&f>=-h?u=ls(r,t,e,n,o,s,i,c):u=[r+a*(e-r),t+a*(n-t)],u}function ls(r,t,e,n,o,s,i,c){let f=null;return!Ot(r,o,i)&&!Ot(t,s,c)?f=[r,t]:!Ot(e,o,i)&&!Ot(n,s,c)?f=[e,n]:!Ot(o,r,e)&&!Ot(s,t,n)?f=[o,s]:!Ot(i,r,e)&&!Ot(c,t,n)&&(f=[i,c]),f}function Ot(r,t,e){let n;return t<e?n=r<t||r>e:t>e?n=r>t||r<e:n=r!=t,n}function us(r,t,...e){let n=-1,o=1/0,s;for(let i=0,c=0,f=e.length;c<f;i++,c+=2)s=ds(r,t,e[c],e[c+1]),s<o&&(o=s,n=i);return n}function ds(r,t,e,n){const o=r-e,s=t-n;return o*o+s*s}function gs(r,t,e,n,o,s,i,c,f){let h=r[0],u=r[1];h=he(h,t,n),h=he(h,s,c),u=he(u,e,o),u=he(u,i,f),r[0]=h,r[1]=u}function he(r,t,e){let n;return Ot(r,t,e)&&(n=Math.abs(r-t)<Math.abs(r-e)?t:e,r=n),r}function ws(r,t,e,n,o,s,i,c){const f=Math.min(r,e,o,i),h=Math.max(r,e,o,i),u=Math.min(t,n,s,c),a=Math.max(t,n,s,c),l=a-u>h-f;let d=[];return(l?jt(t,u,a):jt(r,f,h))&&d.push(r,t),(l?jt(n,u,a):jt(e,f,h))&&d.push(e,n),(l?jt(s,u,a):jt(o,f,h))&&d.push(o,s),(l?jt(c,u,a):jt(i,f,h))&&d.push(i,c),(d.length!=2&&d.length!=4||d.length==4&&d[0]==d[2]&&d[1]==d[3])&&(d=null),d}function ps(r,t,e,n,o,s,i,c){return r==o&&t==s||r==i&&t==c||e==o&&n==s||e==i&&n==c}function jt(r,t,e){return r>t&&r<e}function ms(r,t){bs(r,t),nn(r,t,0,t.length-2)}function bs(r,t){for(let e=0,n=t.length;e<n;e+=2)r[t[e]]>r[t[e+1]]&&ys(t,e,e+1)}function ys(r,t,e){const n=r[t];r[t]=r[e],r[e]=n}function nn(r,t,e,n){let o=e,s=n,i,c;for(;o<n;){for(i=r[t[e+n>>2<<1]];o<=s;){for(;r[t[o]]<i;)o+=2;for(;r[t[s]]>i;)s-=2;o<=s&&(c=t[o],t[o]=t[s],t[s]=c,c=t[o+1],t[o+1]=t[s+1],t[s+1]=c,o+=2,s-=2)}if(s-e<40?sn(r,t,e,s):nn(r,t,e,s),n-o<40){sn(r,t,o,n);return}e=o,s=n}}function sn(r,t,e,n){let o,s;for(let i=e+2;i<=n;i+=2){o=t[i],s=t[i+1];let c;for(c=i-2;c>=e&&r[o]<r[t[c]];c-=2)t[c+2]=t[c],t[c+3]=t[c+1];t[c+2]=o,t[c+3]=s}}function on(r,t,e,n,o){const s=r[0],i=r[1];t=rn(s,i,t[0],t[1],n,o),e=rn(s,i,e[0],e[1],n,o);const c=t[0]<e[0]?t:e,f=c==t?e:t;return{x:s,y:i,a:c,b:f}}function rn(r,t,e,n,o,s){let i=e<n?e:n,c=i===e?n:e;return o[i]==r&&s[i]==t?c=i:o[c]==r&&s[c]==t&&(i=c),[i,c]}function cn(r){const t={};return r.filter(e=>{const n=_s(e);return n in t?!1:(t[n]=!0,!0)})}function _s(r){return`${r.a.join(",")};${r.b.join(",")}`}class ks{_i=0;_n=0;_inc=1;_xx;_yy;i=0;x=0;y=0;constructor(t,e){this._xx=t,this._yy=e}}function xs(r,t,e,n){let o=e|0;const s=isNaN(n)?r.length-o:n+o;let i,c,f,h,u,a;if(s>0)f=u=r[o],h=a=t[o];else return[void 0,void 0,void 0,void 0];for(o++;o<s;o++)i=r[o],c=t[o],i<f&&(f=i),i>u&&(u=i),c<h&&(h=c),c>a&&(a=c);return[f,h,u,a]}class fe{xmin;ymin;xmax;ymax;constructor(...t){t.length>0&&this.setBounds(t)}cloneBounds(){return this.clone()}clone(){return new fe(this.xmin,this.ymin,this.xmax,this.ymax)}width(){return this.xmax-this.xmin||0}height(){return this.ymax-this.ymin||0}setBounds(t,e,n,o){return arguments.length==1&&(Ae(t)?(e=t[1],n=t[2],o=t[3],t=t[0]):(e=t.ymin,n=t.xmax,o=t.ymax,t=t.xmin)),this.xmin=t,this.ymin=e,this.xmax=n,this.ymax=o,(t>n||e>o)&&this.update(),this}update(){let t;this.xmin>this.xmax&&(t=this.xmin,this.xmin=this.xmax,this.xmax=t),this.ymin>this.ymax&&(t=this.ymin,this.ymin=this.ymax,this.ymax=t)}mergeBounds(t,...e){let n,o,s,i;return t instanceof fe?(n=t.xmin,o=t.ymin,s=t.xmax,i=t.ymax):e.length==3?(n=t,o=e[0],s=e[1],i=e[2]):t.length==4?(n=t[0],o=t[1],s=t[2],i=t[3]):Me("Bounds#mergeBounds() invalid argument:",t),this.xmin===void 0?this.setBounds(n,o,s,i):(n<this.xmin&&(this.xmin=n),o<this.ymin&&(this.ymin=o),s>this.xmax&&(this.xmax=s),i>this.ymax&&(this.ymax=i)),this}}function le(r){const t=["a","b","c"].map(e=>r.properties[e].index);return[[0,1],[0,2],[1,2],[0,1,2]].map(e=>e.map(n=>t[n]).sort().join("-")).sort()}function ve(r,t,e){const n=le(t.forw),o=le(t.bakw);if(JSON.stringify(n)!=JSON.stringify(o))throw`${JSON.stringify(t,null,2)}
${JSON.stringify(n)}
${JSON.stringify(o)}`;for(let s=0;s<n.length;s++){const i=n[s];r[i]||(r[i]=[]),r[i].push(t)}e&&(e.forw.features.push(t.forw),e.bakw.features.push(t.bakw))}function an(r,t,e){const n=le(t.forw),o=le(t.bakw);if(JSON.stringify(n)!=JSON.stringify(o))throw`${JSON.stringify(t,null,2)}
${JSON.stringify(n)}
${JSON.stringify(o)}`;if(n.forEach(s=>{const i=r[s];if(!i)return;const c=i.filter(f=>f!==t);c.length===0?delete r[s]:r[s]=c}),e){const s=(i,c)=>{!i||!c||(i.features=i.features.filter(f=>f!==c))};s(e.forw,t.forw),s(e.bakw,t.bakw)}}function Ht(r,t,e){return at.point(r,{target:{geom:t,index:e}})}function Zt(r){return at.point(r.properties.target.geom,{target:{geom:r.geometry.coordinates,index:r.properties.target.index}})}function Ee(r,t){const e=t.geometry.coordinates;return[0,1,2,3].map(n=>{const o=(n+1)%4,s=r[n],i=r[o],c=s.geometry.coordinates,f=Math.atan2(c[0]-e[0],c[1]-e[1]),h=[t,s,i,t].map(l=>l.geometry.coordinates),u={a:{geom:t.properties.target.geom,index:t.properties.target.index},b:{geom:s.properties.target.geom,index:s.properties.target.index},c:{geom:i.properties.target.geom,index:i.properties.target.index}},a=at.featureCollection([at.polygon([h],u)]);return[f,a]}).reduce((n,o)=>(n[0].push(o[0]),n[1].push(o[1]),n),[[],[]])}function Ss(r){const{tins:t,targets:e,includeReciprocals:n}=r,o={};e.forEach(i=>{const c=t[i];if(!c||!c.features)return;o[i]={};const f={};c.features.forEach(h=>{const u=["a","b","c"];for(let a=0;a<3;a++){const l=(a+1)%3,d=u[a],m=u[l],g=h.properties[d].index,b=h.properties[m].index,p=[g,b].sort().join("-");if(f[p])continue;f[p]=!0;const S=h.geometry.coordinates[0][a],v=h.geometry.coordinates[0][l],I=h.properties[d].geom,R=h.properties[m].geom,N=Math.sqrt(Math.pow(I[0]-R[0],2)+Math.pow(I[1]-R[1],2))/Math.sqrt(Math.pow(S[0]-v[0],2)+Math.pow(S[1]-v[1],2)),j=o[i];j[`${g}:${p}`]=N,j[`${b}:${p}`]=N}})});const s={};return n&&(s.bakw={}),e.forEach(i=>{const c=o[i];if(s[i]={},!c)return;const f={};Object.keys(c).forEach(u=>{const[a]=u.split(":");f[a]||(f[a]=[]),f[a].push(c[u])}),Object.keys(f).forEach(u=>{const a=f[u],l=a.reduce((d,m)=>d+m,0)/a.length;s[i][u]=l,n&&s.bakw&&(s.bakw[u]=1/l)});let h=0;for(let u=0;u<4;u++){const a=`b${u}`,l=s[i][a]||0;h+=l}s[i].c=h/4,n&&s.bakw&&(s.bakw.c=1/s[i].c)}),s}function Ms(r,t){const e=r.split("-");if(e.length!==2||!e.every(s=>/^-?\d+$/.test(s)))return!1;const[n,o]=e.map(s=>parseInt(s,10)).sort((s,i)=>s-i);return t.some(s=>{if(s.length!==2)return!1;const i=s.map(f=>parseInt(`${f}`,10));if(i.some(f=>Number.isNaN(f)))return!1;const c=i.sort((f,h)=>f-h);return c[0]===n&&c[1]===o})}function hn(r){return["a","b","c"].map((t,e)=>({prop:r.properties[t],geom:r.geometry.coordinates[0][e]}))}function As(r,t,e){let n=!1,o=!0;for(;o;){o=!1;const s=Object.keys(t);for(const i of s){const c=t[i];if(!c||c.length<2||Ms(i,e))continue;const f=i.split("-"),h=hn(c[0].bakw),u=hn(c[1].bakw),a=f.map(b=>h.find(p=>`${p.prop.index}`===b)||u.find(p=>`${p.prop.index}`===b));if(a.some(b=>!b))continue;const l=[h,u].map(b=>b.find(p=>!f.includes(`${p.prop.index}`)));if(l.some(b=>!b))continue;const d=c[0].bakw.geometry.coordinates[0].slice(0,3).map(b=>ue(b)),m=c[1].bakw.geometry.coordinates[0].slice(0,3).map(b=>ue(b));if(fn(ue(l[0].geom),m)||fn(ue(l[1].geom),d)){an(t,c[0],r),an(t,c[1],r),a.forEach(b=>{if(!b)return;const p=[b.geom,l[0].geom,l[1].geom,b.geom],S={a:b.prop,b:l[0].prop,c:l[1].prop},v=at.polygon([p],S),I=Ue(v);ve(t,{forw:I,bakw:v},r)}),n=!0,o=!0;break}}}return n}function ue(r){return[r[0],r[1]]}function fn(r,t){const[e,n]=t[0],[o,s]=t[1],[i,c]=t[2],f=i-e,h=c-n,u=o-e,a=s-n,l=r[0]-e,d=r[1]-n,m=f*f+h*h,g=f*u+h*a,b=f*l+h*d,p=u*u+a*a,S=u*l+a*d,v=m*p-g*g;if(v===0)return!1;const I=1/v,R=(p*b-g*S)*I,N=(m*S-g*b)*I,j=1e-9;return R>=-j&&N>=-j&&R+N<=1+j}const ln=se;class ct extends Nn{importance;priority;pointsSet;constructor(t={}){super(),t.bounds?this.setBounds(t.bounds):(this.setWh(t.wh),this.vertexMode=t.vertexMode||ct.VERTEX_PLAIN),this.strictMode=t.strictMode||ct.MODE_AUTO,this.yaxisMode=t.yaxisMode||ct.YAXIS_INVERT,this.importance=t.importance||0,this.priority=t.priority||0,this.stateFull=t.stateFull||!1,t.points&&this.setPoints(t.points),t.edges&&this.setEdges(t.edges)}getFormatVersion(){return ln}setPoints(t){this.yaxisMode===ct.YAXIS_FOLLOW&&(t=t.map(e=>[e[0],[e[1][0],-1*e[1][1]]])),this.points=t,this.tins=void 0,this.indexedTins=void 0}setEdges(t=[]){this.edges=$e(t),this.edgeNodes=void 0,this.tins=void 0,this.indexedTins=void 0}setBounds(t){this.bounds=t;let e=t[0][0],n=e,o=t[0][1],s=o;const i=[t[0]];for(let c=1;c<t.length;c++){const f=t[c];f[0]<e&&(e=f[0]),f[0]>n&&(n=f[0]),f[1]<o&&(o=f[1]),f[1]>s&&(s=f[1]),i.push(f)}i.push(t[0]),this.boundsPolygon=at.polygon([i]),this.xy=[e,o],this.wh=[n-e,s-o],this.vertexMode=ct.VERTEX_PLAIN,this.tins=void 0,this.indexedTins=void 0}getCompiled(){const t={};t.version=ln,t.points=this.points,t.weight_buffer=this.pointsWeightBuffer,t.centroid_point=[this.centroid.forw.geometry.coordinates,this.centroid.forw.properties.target.geom],t.vertices_params=[this.vertices_params.forw[0],this.vertices_params.bakw[0]],t.vertices_points=[];const e=this.vertices_params.forw[1];return e&&[0,1,2,3].map(n=>{const o=e[n].features[0],s=o.geometry.coordinates[0][1],i=o.properties.b.geom;t.vertices_points[n]=[s,i]}),t.strict_status=this.strict_status,t.tins_points=[[]],this.tins.forw.features.map(n=>{t.tins_points[0].push(["a","b","c"].map(o=>n.properties[o].index))}),this.strict_status===ct.STATUS_LOOSE?(t.tins_points[1]=[],this.tins.bakw.features.map(n=>{t.tins_points[1].push(["a","b","c"].map(o=>n.properties[o].index))})):this.strict_status===ct.STATUS_ERROR&&this.kinks?.bakw&&(t.kinks_points=this.kinks.bakw.features.map(n=>n.geometry.coordinates)),t.yaxisMode=this.yaxisMode,t.vertexMode=this.vertexMode,t.strictMode=this.strictMode,this.bounds?(t.bounds=this.bounds,t.boundsPolygon=this.boundsPolygon,t.xy=this.xy,t.wh=this.wh):t.wh=this.wh,t.edges=this.edges,t.edgeNodes=this.edgeNodes,t}setWh(t){this.wh=t||[100,100],this.xy=[0,0],this.bounds=void 0,this.boundsPolygon=void 0,this.tins=void 0,this.indexedTins=void 0}setVertexMode(t){this.vertexMode=t,this.tins=void 0,this.indexedTins=void 0}setStrictMode(t){this.strictMode=t,this.tins=void 0,this.indexedTins=void 0}calcurateStrictTin(){const t=this.tins.forw.features.map(o=>Ue(o));this.tins.bakw=at.featureCollection(t);const e={};this.tins.forw.features.forEach((o,s)=>{const i=this.tins.bakw.features[s];ve(e,{forw:o,bakw:i})}),As(this.tins,e,this.pointsSet?.edges||[]);const n=["forw","bakw"].map(o=>{const s=this.tins[o].features.map(i=>i.geometry.coordinates[0]);return tn(s)});n[0].length===0&&n[1].length===0?(this.strict_status=ct.STATUS_STRICT,delete this.kinks):(this.strict_status=ct.STATUS_ERROR,this.kinks={},n[0].length>0&&(this.kinks.forw=at.featureCollection(n[0])),n[1].length>0&&(this.kinks.bakw=at.featureCollection(n[1])))}generatePointsSet(){const t={forw:[],bakw:[]};for(let o=0;o<this.points.length;o++){const s=this.points[o][0],i=this.points[o][1],c=Ht(s,i,o);t.forw.push(c),t.bakw.push(Zt(c))}const e=[];let n=0;this.edgeNodes=[],this.edges||(this.edges=[]);for(let o=0;o<this.edges.length;o++){const s=this.edges[o][2],i=Object.assign([],this.edges[o][0]),c=Object.assign([],this.edges[o][1]);if(i.length===0&&c.length===0){e.push(s);continue}i.unshift(this.points[s[0]][0]),i.push(this.points[s[1]][0]),c.unshift(this.points[s[0]][1]),c.push(this.points[s[1]][1]);const f=[i,c].map(h=>{const u=h.map((l,d,m)=>{if(d===0)return 0;const g=m[d-1];return Math.sqrt(Math.pow(l[0]-g[0],2)+Math.pow(l[1]-g[1],2))}),a=u.reduce((l,d,m)=>m===0?[0]:(l.push(l[m-1]+d),l),[]);return a.map((l,d,m)=>{const g=l/m[m.length-1];return[h[d],u[d],a[d],g]})});f.map((h,u)=>{const a=f[u?0:1];return h.filter((l,d)=>!(d===0||d===h.length-1||l[4]==="handled")).map(l=>{const d=l[0],m=l[3],g=a.reduce((b,p,S,v)=>{if(b)return b;const I=v[S+1];if(p[3]===m)return p[4]="handled",[p];if(p[3]<m&&I&&I[3]>m)return[p,I]},void 0);if(g&&g.length===1)return u===0?[d,g[0][0],m]:[g[0][0],d,m];if(g&&g.length===2){const b=g[0],p=g[1],S=(m-b[3])/(p[3]-b[3]),v=[(p[0][0]-b[0][0])*S+b[0][0],(p[0][1]-b[0][1])*S+b[0][1]];return u===0?[d,v,m]:[v,d,m]}return[]})}).reduce((h,u)=>h.concat(u),[]).sort((h,u)=>h[2]<u[2]?-1:1).map((h,u,a)=>{this.edgeNodes[n]=[h[0],h[1]];const l=Ht(h[0],h[1],`e${n}`);n++,t.forw.push(l),t.bakw.push(Zt(l)),u===0?e.push([s[0],t.forw.length-1]):e.push([t.forw.length-2,t.forw.length-1]),u===a.length-1&&e.push([t.forw.length-1,s[1]])})}return{forw:t.forw,bakw:t.bakw,edges:e}}validateAndPrepareInputs(){const t=this.xy[0]-.05*this.wh[0],e=this.xy[0]+1.05*this.wh[0],n=this.xy[1]-.05*this.wh[1],o=this.xy[1]+1.05*this.wh[1];if(!this.points.reduce((c,f)=>c&&(this.bounds?Yt(f[0],this.boundsPolygon):f[0][0]>=t&&f[0][0]<=e&&f[0][1]>=n&&f[0][1]<=o),!0))throw"SOME POINTS OUTSIDE";let i=[];return this.wh&&(i=[[t,n],[e,n],[t,o],[e,o]]),{pointsSet:this.generatePointsSet(),bbox:i,minx:t,maxx:e,miny:n,maxy:o}}updateTin(){let t=this.strictMode;t!==ct.MODE_STRICT&&t!==ct.MODE_LOOSE&&(t=ct.MODE_AUTO);const{pointsSet:e,bbox:n,minx:o,maxx:s,miny:i,maxy:c}=this.validateAndPrepareInputs(),f={forw:at.featureCollection(e.forw),bakw:at.featureCollection(e.bakw)},h=Qt(f.forw,e.edges,"target"),u=Qt(f.bakw,e.edges,"target");if(h.features.length===0||u.features.length===0)throw"TOO LINEAR1";const a=un(f.forw),l=Te(f.forw);if(!l)throw"TOO LINEAR2";const d={},m=l.geometry.coordinates[0];let g;try{g=m.map(E=>({forw:E,bakw:ne(at.point(E),h)})),g.forEach(E=>{d[`${E.forw[0]}:${E.forw[1]}`]=E})}catch{throw"TOO LINEAR2"}const b=Te(f.bakw);if(!b)throw"TOO LINEAR2";const p=b.geometry.coordinates[0];try{g=p.map(E=>({bakw:E,forw:ne(at.point(E),u)})),g.forEach(E=>{d[`${E.forw[0]}:${E.forw[1]}`]=E})}catch{throw"TOO LINEAR2"}const S={forw:a.geometry.coordinates,bakw:ne(a,h)},v=Ht(S.forw,S.bakw,"c");this.centroid={forw:v,bakw:Zt(v)};const I={convexBuf:d,centroid:S,bbox:n,minx:o,maxx:s,miny:i,maxy:c},R=this.vertexMode===ct.VERTEX_BIRDEYE?ts(I):Zn(I),N={forw:[],bakw:[]};for(let E=0;E<R.length;E++){const V=R[E].forw,L=R[E].bakw,z=Ht(V,L,`b${E}`),W=Zt(z);e.forw.push(z),e.bakw.push(W),N.forw.push(z),N.bakw.push(W)}this.pointsSet={forw:at.featureCollection(e.forw),bakw:at.featureCollection(e.bakw),edges:e.edges},this.tins={forw:je(Qt(this.pointsSet.forw,e.edges,"target"))},(t===ct.MODE_STRICT||t===ct.MODE_AUTO)&&this.calcurateStrictTin(),(t===ct.MODE_LOOSE||t===ct.MODE_AUTO&&this.strict_status===ct.STATUS_ERROR)&&(this.tins.bakw=je(Qt(this.pointsSet.bakw,e.edges,"target")),delete this.kinks,this.strict_status=ct.STATUS_LOOSE),this.vertices_params={forw:Ee(N.forw,this.centroid.forw),bakw:Ee(N.bakw,this.centroid.bakw)},this.addIndexedTin();const j=["forw"];this.strict_status===ct.STATUS_LOOSE&&j.push("bakw");const X=this.strict_status===ct.STATUS_STRICT;this.pointsWeightBuffer=Ss({tins:this.tins,targets:j,includeReciprocals:X})}async updateTinAsync(){this.updateTin()}}ft.Tin=ct,ft.constrainedTin=Qt,ft.counterPoint=Zt,ft.createPoint=Ht,ft.findIntersections=tn,ft.format_version=se,ft.insertSearchIndex=ve,ft.vertexCalc=Ee,Object.defineProperty(ft,Symbol.toStringTag,{value:"Module"})}));
