"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const ln=require("@turf/boolean-point-in-polygon"),fn=require("@turf/centroid"),ve=require("@turf/convex"),ht=require("@turf/helpers"),un=require("@turf/line-intersect");var dn=Object.defineProperty,gn=(r,t,e)=>t in r?dn(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e,it=(r,t,e)=>gn(r,typeof t!="symbol"?t+"":t,e);const Tt=11102230246251565e-32,ut=134217729,pn=(3+8*Tt)*Tt;function fe(r,t,e,n,o){let s,i,c,l,h=t[0],u=n[0],a=0,f=0;u>h==u>-h?(s=h,h=t[++a]):(s=u,u=n[++f]);let d=0;if(a<r&&f<e)for(u>h==u>-h?(i=h+s,c=s-(i-h),h=t[++a]):(i=u+s,c=s-(i-u),u=n[++f]),s=i,c!==0&&(o[d++]=c);a<r&&f<e;)u>h==u>-h?(i=s+h,l=i-s,c=s-(i-l)+(h-l),h=t[++a]):(i=s+u,l=i-s,c=s-(i-l)+(u-l),u=n[++f]),s=i,c!==0&&(o[d++]=c);for(;a<r;)i=s+h,l=i-s,c=s-(i-l)+(h-l),h=t[++a],s=i,c!==0&&(o[d++]=c);for(;f<e;)i=s+u,l=i-s,c=s-(i-l)+(u-l),u=n[++f],s=i,c!==0&&(o[d++]=c);return(s!==0||d===0)&&(o[d++]=s),d}function wn(r,t){let e=t[0];for(let n=1;n<r;n++)e+=t[n];return e}function Ht(r){return new Float64Array(r)}const mn=(3+16*Tt)*Tt,bn=(2+12*Tt)*Tt,yn=(9+64*Tt)*Tt*Tt,Lt=Ht(4),Ee=Ht(8),Ie=Ht(12),Oe=Ht(16),gt=Ht(4);function _n(r,t,e,n,o,s,i){let c,l,h,u,a,f,d,m,g,b,w,S,v,O,R,N,U,X;const E=r-o,V=e-o,L=t-s,z=n-s;O=E*z,f=ut*E,d=f-(f-E),m=E-d,f=ut*z,g=f-(f-z),b=z-g,R=m*b-(O-d*g-m*g-d*b),N=L*V,f=ut*L,d=f-(f-L),m=L-d,f=ut*V,g=f-(f-V),b=V-g,U=m*b-(N-d*g-m*g-d*b),w=R-U,a=R-w,Lt[0]=R-(w+a)+(a-U),S=O+w,a=S-O,v=O-(S-a)+(w-a),w=v-N,a=v-w,Lt[1]=v-(w+a)+(a-N),X=S+w,a=X-S,Lt[2]=S-(X-a)+(w-a),Lt[3]=X;let W=wn(4,Lt),p=bn*i;if(W>=p||-W>=p||(a=r-E,c=r-(E+a)+(a-o),a=e-V,h=e-(V+a)+(a-o),a=t-L,l=t-(L+a)+(a-s),a=n-z,u=n-(z+a)+(a-s),c===0&&l===0&&h===0&&u===0)||(p=yn*i+pn*Math.abs(W),W+=E*u+z*c-(L*h+V*l),W>=p||-W>=p))return W;O=c*z,f=ut*c,d=f-(f-c),m=c-d,f=ut*z,g=f-(f-z),b=z-g,R=m*b-(O-d*g-m*g-d*b),N=l*V,f=ut*l,d=f-(f-l),m=l-d,f=ut*V,g=f-(f-V),b=V-g,U=m*b-(N-d*g-m*g-d*b),w=R-U,a=R-w,gt[0]=R-(w+a)+(a-U),S=O+w,a=S-O,v=O-(S-a)+(w-a),w=v-N,a=v-w,gt[1]=v-(w+a)+(a-N),X=S+w,a=X-S,gt[2]=S-(X-a)+(w-a),gt[3]=X;const y=fe(4,Lt,4,gt,Ee);O=E*u,f=ut*E,d=f-(f-E),m=E-d,f=ut*u,g=f-(f-u),b=u-g,R=m*b-(O-d*g-m*g-d*b),N=L*h,f=ut*L,d=f-(f-L),m=L-d,f=ut*h,g=f-(f-h),b=h-g,U=m*b-(N-d*g-m*g-d*b),w=R-U,a=R-w,gt[0]=R-(w+a)+(a-U),S=O+w,a=S-O,v=O-(S-a)+(w-a),w=v-N,a=v-w,gt[1]=v-(w+a)+(a-N),X=S+w,a=X-S,gt[2]=S-(X-a)+(w-a),gt[3]=X;const _=fe(y,Ee,4,gt,Ie);O=c*u,f=ut*c,d=f-(f-c),m=c-d,f=ut*u,g=f-(f-u),b=u-g,R=m*b-(O-d*g-m*g-d*b),N=l*h,f=ut*l,d=f-(f-l),m=l-d,f=ut*h,g=f-(f-h),b=h-g,U=m*b-(N-d*g-m*g-d*b),w=R-U,a=R-w,gt[0]=R-(w+a)+(a-U),S=O+w,a=S-O,v=O-(S-a)+(w-a),w=v-N,a=v-w,gt[1]=v-(w+a)+(a-N),X=S+w,a=X-S,gt[2]=S-(X-a)+(w-a),gt[3]=X;const x=fe(_,Ie,4,gt,Oe);return Oe[x-1]}function kn(r,t,e,n,o,s){const i=(t-s)*(e-o),c=(r-o)*(n-s),l=i-c,h=Math.abs(i+c);return Math.abs(l)>=mn*h?l:-_n(r,t,e,n,o,s,h)}function xn(r,t){var e,n,o=0,s,i,c,l,h,u,a,f=r[0],d=r[1],m=t.length;for(e=0;e<m;e++){n=0;var g=t[e],b=g.length-1;if(u=g[0],u[0]!==g[b][0]&&u[1]!==g[b][1])throw new Error("First and last coordinates in a ring must be the same");for(i=u[0]-f,c=u[1]-d,n;n<b;n++){if(a=g[n+1],l=a[0]-f,h=a[1]-d,c===0&&h===0){if(l<=0&&i>=0||i<=0&&l>=0)return 0}else if(h>=0&&c<=0||h<=0&&c>=0){if(s=kn(i,l,c,h,0,0),s===0)return 0;(s>0&&h>0&&c<=0||s<0&&h<=0&&c>0)&&o++}u=a,c=h,i=l}}return o%2!==0}function Je(r,t,e={}){const n={type:"Feature"};return(e.id===0||e.id)&&(n.id=e.id),e.bbox&&(n.bbox=e.bbox),n.properties=t||{},n.geometry=r,n}function Yt(r,t,e={}){if(!r)throw new Error("coordinates is required");if(!Array.isArray(r))throw new Error("coordinates must be an Array");if(r.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!Te(r[0])||!Te(r[1]))throw new Error("coordinates must contain numbers");return Je({type:"Point",coordinates:r},t,e)}function Ke(r,t,e={}){for(const n of r){if(n.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");if(n[n.length-1].length!==n[0].length)throw new Error("First and last Position are not equivalent.");for(let o=0;o<n[n.length-1].length;o++)if(n[n.length-1][o]!==n[0][o])throw new Error("First and last Position are not equivalent.")}return Je({type:"Polygon",coordinates:r},t,e)}function Ft(r,t={}){const e={type:"FeatureCollection"};return t.id&&(e.id=t.id),t.bbox&&(e.bbox=t.bbox),e.features=r,e}function Te(r){return!isNaN(r)&&r!==null&&!Array.isArray(r)}function Sn(r){if(!r)throw new Error("coord is required");if(!Array.isArray(r)){if(r.type==="Feature"&&r.geometry!==null&&r.geometry.type==="Point")return[...r.geometry.coordinates];if(r.type==="Point")return[...r.coordinates]}if(Array.isArray(r)&&r.length>=2&&!Array.isArray(r[0])&&!Array.isArray(r[1]))return[...r];throw new Error("coord must be GeoJSON Point or an Array of numbers")}function Ne(r){if(Array.isArray(r))return r;if(r.type==="Feature"){if(r.geometry!==null)return r.geometry.coordinates}else if(r.coordinates)return r.coordinates;throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")}function Mn(r){return r.type==="Feature"?r.geometry:r}function An(r,t,e={}){if(!r)throw new Error("point is required");if(!t)throw new Error("polygon is required");const n=Sn(r),o=Mn(t),s=o.type,i=t.bbox;let c=o.coordinates;if(i&&vn(n,i)===!1)return!1;s==="Polygon"&&(c=[c]);let l=!1;for(var h=0;h<c.length;++h){const u=xn(n,c[h]);if(u===0)return!e.ignoreBoundary;u&&(l=!0)}return l}function vn(r,t){return t[0]<=r[0]&&t[1]<=r[1]&&t[2]>=r[0]&&t[3]>=r[1]}var _e=An;function Ce(r){const t=r.features;for(let e=0;e<t.length;e++){const n=t[e];`${n.properties.a.index}`.substring(0,1)==="b"&&`${n.properties.b.index}`.substring(0,1)==="b"?t[e]={geometry:{type:"Polygon",coordinates:[[n.geometry.coordinates[0][2],n.geometry.coordinates[0][0],n.geometry.coordinates[0][1],n.geometry.coordinates[0][2]]]},properties:{a:{geom:n.properties.c.geom,index:n.properties.c.index},b:{geom:n.properties.a.geom,index:n.properties.a.index},c:{geom:n.properties.b.geom,index:n.properties.b.index}},type:"Feature"}:`${n.properties.c.index}`.substring(0,1)==="b"&&`${n.properties.a.index}`.substring(0,1)==="b"&&(t[e]={geometry:{type:"Polygon",coordinates:[[n.geometry.coordinates[0][1],n.geometry.coordinates[0][2],n.geometry.coordinates[0][0],n.geometry.coordinates[0][1]]]},properties:{a:{geom:n.properties.b.geom,index:n.properties.b.index},b:{geom:n.properties.c.geom,index:n.properties.c.index},c:{geom:n.properties.a.geom,index:n.properties.a.index}},type:"Feature"})}return r}function Qe(r){const t=["a","b","c","a"].map(s=>r.properties[s].geom),e=r.geometry.coordinates[0],n=r.properties,o={a:{geom:e[0],index:n.a.index},b:{geom:e[1],index:n.b.index},c:{geom:e[2],index:n.c.index}};return Ke([t],o)}function En(r){const t=[0,1,2,0].map(n=>r[n][0][0]),e={a:{geom:r[0][0][1],index:r[0][1]},b:{geom:r[1][0][1],index:r[1][1]},c:{geom:r[2][0][1],index:r[2][1]}};return Ke([t],e)}function Zt(r,t,e,n,o,s=!1,i){const c=r.map(l=>{(!i||i<2.00703)&&(l=Ge(l));const h=isFinite(l)?t[l]:l==="c"?n:l==="b0"?o[0]:l==="b1"?o[1]:l==="b2"?o[2]:l==="b3"?o[3]:(function(){const u=l.match(/e(\d+)/);if(u){const a=parseInt(u[1]);return e[a]}throw"Bad index value for indexesToTri"})();return s?[[h[1],h[0]],l]:[[h[0],h[1]],l]});return En(c)}function Ge(r){return typeof r=="number"?r:r.replace(/^(c|e|b)(?:ent|dgeNode|box)(\d+)?$/,"$1$2")}function He(r,t){return t&&t>=2.00703||Array.isArray(r[0])?r:r.map(e=>[e.illstNodes,e.mercNodes,e.startEnd])}function Re(r,t){for(let e=0;e<t.features.length;e++)if(_e(r,t.features[e]))return t.features[e]}function Ze(r,t,e){const n=t.geometry.coordinates[0][0],o=t.geometry.coordinates[0][1],s=t.geometry.coordinates[0][2],i=r.geometry.coordinates,c=t.properties.a.geom,l=t.properties.b.geom,h=t.properties.c.geom,u=[o[0]-n[0],o[1]-n[1]],a=[s[0]-n[0],s[1]-n[1]],f=[i[0]-n[0],i[1]-n[1]],d=[l[0]-c[0],l[1]-c[1]],m=[h[0]-c[0],h[1]-c[1]];let g=(a[1]*f[0]-a[0]*f[1])/(u[0]*a[1]-u[1]*a[0]),b=(u[0]*f[1]-u[1]*f[0])/(u[0]*a[1]-u[1]*a[0]);if(e){const w=e[t.properties.a.index],S=e[t.properties.b.index],v=e[t.properties.c.index];let O;if(g<0||b<0||1-g-b<0){const R=g/(g+b),N=b/(g+b);O=g/S/(R/S+N/v),b=b/v/(R/S+N/v)}else O=g/S/(g/S+b/v+(1-g-b)/w),b=b/v/(g/S+b/v+(1-g-b)/w);g=O}return[g*d[0]+b*m[0]+c[0],g*d[1]+b*m[1]+c[1]]}function In(r,t,e,n){const o=r.geometry.coordinates,s=e.geometry.coordinates,i=Math.atan2(o[0]-s[0],o[1]-s[1]),c=On(i,t[0]);if(c===void 0)throw new Error("Unable to determine vertex index");const l=t[1][c];return Ze(r,l.features[0],n)}function ce(r,t,e,n,o,s,i,c){let l;if(i&&(l=Re(r,Ft([i]))),!l){if(e){const h=r.geometry.coordinates,u=e.gridNum,a=e.xOrigin,f=e.yOrigin,d=e.xUnit,m=e.yUnit,g=e.gridCache,b=At(h[0],a,d,u),w=At(h[1],f,m,u),S=g[b]?g[b][w]?g[b][w]:[]:[];t=Ft(S.map(v=>t.features[v]))}l=Re(r,t)}return c&&c(l),l?Ze(r,l,s):In(r,n,o,s)}function At(r,t,e,n){let o=Math.floor((r-t)/e);return o>=n&&(o=n-1),o}function On(r,t){let e=Be(r-t[0]),n=Math.PI*2,o;for(let s=0;s<t.length;s++){const i=(s+1)%t.length,c=Be(r-t[i]),l=Math.min(Math.abs(e),Math.abs(c));e*c<=0&&l<n&&(n=l,o=s),e=c}return o}function Be(r,t=!1){const e=t?function(n){return!(n>=0&&n<Math.PI*2)}:function(n){return!(n>-1*Math.PI&&n<=Math.PI)};for(;e(r);)r=r+2*Math.PI*(r>0?-1:1);return r}const ae=2.00703,_t=class kt{constructor(){it(this,"points",[]),it(this,"pointsWeightBuffer"),it(this,"strict_status"),it(this,"vertices_params"),it(this,"centroid"),it(this,"edgeNodes"),it(this,"edges"),it(this,"tins"),it(this,"kinks"),it(this,"yaxisMode",kt.YAXIS_INVERT),it(this,"strictMode",kt.MODE_AUTO),it(this,"vertexMode",kt.VERTEX_PLAIN),it(this,"bounds"),it(this,"boundsPolygon"),it(this,"wh"),it(this,"xy"),it(this,"indexedTins"),it(this,"stateFull",!1),it(this,"stateTriangle"),it(this,"stateBackward")}setCompiled(t){if(t.version||!t.tins&&t.points&&t.tins_points){this.points=t.points,this.pointsWeightBuffer=!t.version||t.version<2.00703?["forw","bakw"].reduce((n,o)=>{const s=t.weight_buffer[o];return s&&(n[o]=Object.keys(s).reduce((i,c)=>{const l=Ge(c);return i[l]=s[c],i},{})),n},{}):t.weight_buffer,t.strict_status?this.strict_status=t.strict_status:t.kinks_points?this.strict_status=kt.STATUS_ERROR:t.tins_points.length==2?this.strict_status=kt.STATUS_LOOSE:this.strict_status=kt.STATUS_STRICT,this.vertices_params={forw:[t.vertices_params[0]],bakw:[t.vertices_params[1]]},this.vertices_params.forw[1]=[0,1,2,3].map(n=>{const o=(n+1)%4,s=Zt(["c",`b${n}`,`b${o}`],t.points,t.edgeNodes||[],t.centroid_point,t.vertices_points,!1,ae);return Ft([s])}),this.vertices_params.bakw[1]=[0,1,2,3].map(n=>{const o=(n+1)%4,s=Zt(["c",`b${n}`,`b${o}`],t.points,t.edgeNodes||[],t.centroid_point,t.vertices_points,!0,ae);return Ft([s])}),this.centroid={forw:Yt(t.centroid_point[0],{target:{geom:t.centroid_point[1],index:"c"}}),bakw:Yt(t.centroid_point[1],{target:{geom:t.centroid_point[0],index:"c"}})},this.edges=He(t.edges||[]),this.edgeNodes=t.edgeNodes||[];const e=t.tins_points.length==1?0:1;this.tins={forw:Ft(t.tins_points[0].map(n=>Zt(n,t.points,t.edgeNodes||[],t.centroid_point,t.vertices_points,!1,t.version))),bakw:Ft(t.tins_points[e].map(n=>Zt(n,t.points,t.edgeNodes||[],t.centroid_point,t.vertices_points,!0,t.version)))},this.addIndexedTin(),t.kinks_points&&(this.kinks={bakw:Ft(t.kinks_points.map(n=>Yt(n)))}),t.yaxisMode?this.yaxisMode=t.yaxisMode:this.yaxisMode=kt.YAXIS_INVERT,t.vertexMode&&(this.vertexMode=t.vertexMode),t.strictMode&&(this.strictMode=t.strictMode),t.bounds?(this.bounds=t.bounds,this.boundsPolygon=t.boundsPolygon,this.xy=t.xy,this.wh=t.wh):(this.xy=[0,0],t.wh&&(this.wh=t.wh),this.bounds=void 0,this.boundsPolygon=void 0)}else{t=JSON.parse(JSON.stringify(t).replace('"cent"','"c"').replace(/"bbox(\d+)"/g,'"b$1"')),this.tins=t.tins,this.addIndexedTin(),this.strict_status=t.strict_status,this.pointsWeightBuffer=t.weight_buffer,this.vertices_params=t.vertices_params,this.centroid=t.centroid,this.kinks=t.kinks;const e=[];for(let n=0;n<this.tins.forw.features.length;n++){const o=this.tins.forw.features[n];["a","b","c"].map((s,i)=>{const c=o.geometry.coordinates[0][i],l=o.properties[s].geom,h=o.properties[s].index;typeof h=="number"&&(e[h]=[c,l])})}this.points=e}}addIndexedTin(){const t=this.tins,e=t.forw,n=t.bakw,o=Math.ceil(Math.sqrt(e.features.length));if(o<3){this.indexedTins=void 0;return}let s=[],i=[];const c=e.features.map(g=>{let b=[];return Ne(g)[0].map(w=>{s.length===0?s=[Array.from(w),Array.from(w)]:(w[0]<s[0][0]&&(s[0][0]=w[0]),w[0]>s[1][0]&&(s[1][0]=w[0]),w[1]<s[0][1]&&(s[0][1]=w[1]),w[1]>s[1][1]&&(s[1][1]=w[1])),b.length===0?b=[Array.from(w),Array.from(w)]:(w[0]<b[0][0]&&(b[0][0]=w[0]),w[0]>b[1][0]&&(b[1][0]=w[0]),w[1]<b[0][1]&&(b[0][1]=w[1]),w[1]>b[1][1]&&(b[1][1]=w[1]))}),b}),l=(s[1][0]-s[0][0])/o,h=(s[1][1]-s[0][1])/o,u=c.reduce((g,b,w)=>{const S=At(b[0][0],s[0][0],l,o),v=At(b[1][0],s[0][0],l,o),O=At(b[0][1],s[0][1],h,o),R=At(b[1][1],s[0][1],h,o);for(let N=S;N<=v;N++){g[N]||(g[N]=[]);for(let U=O;U<=R;U++)g[N][U]||(g[N][U]=[]),g[N][U].push(w)}return g},[]),a=n.features.map(g=>{let b=[];return Ne(g)[0].map(w=>{i.length===0?i=[Array.from(w),Array.from(w)]:(w[0]<i[0][0]&&(i[0][0]=w[0]),w[0]>i[1][0]&&(i[1][0]=w[0]),w[1]<i[0][1]&&(i[0][1]=w[1]),w[1]>i[1][1]&&(i[1][1]=w[1])),b.length===0?b=[Array.from(w),Array.from(w)]:(w[0]<b[0][0]&&(b[0][0]=w[0]),w[0]>b[1][0]&&(b[1][0]=w[0]),w[1]<b[0][1]&&(b[0][1]=w[1]),w[1]>b[1][1]&&(b[1][1]=w[1]))}),b}),f=(i[1][0]-i[0][0])/o,d=(i[1][1]-i[0][1])/o,m=a.reduce((g,b,w)=>{const S=At(b[0][0],i[0][0],f,o),v=At(b[1][0],i[0][0],f,o),O=At(b[0][1],i[0][1],d,o),R=At(b[1][1],i[0][1],d,o);for(let N=S;N<=v;N++){g[N]||(g[N]=[]);for(let U=O;U<=R;U++)g[N][U]||(g[N][U]=[]),g[N][U].push(w)}return g},[]);this.indexedTins={forw:{gridNum:o,xOrigin:s[0][0],yOrigin:s[0][1],xUnit:l,yUnit:h,gridCache:u},bakw:{gridNum:o,xOrigin:i[0][0],yOrigin:i[0][1],xUnit:f,yUnit:d,gridCache:m}}}transform(t,e,n){if(e&&this.strict_status==kt.STATUS_ERROR)throw'Backward transform is not allowed if strict_status == "strict_error"';this.yaxisMode==kt.YAXIS_FOLLOW&&e&&(t=[t[0],-1*t[1]]);const o=Yt(t);if(this.bounds&&!e&&!n&&!_e(o,this.boundsPolygon))return!1;const s=e?this.tins.bakw:this.tins.forw,i=e?this.indexedTins.bakw:this.indexedTins.forw,c=e?this.vertices_params.bakw:this.vertices_params.forw,l=e?this.centroid.bakw:this.centroid.forw,h=e?this.pointsWeightBuffer.bakw:this.pointsWeightBuffer.forw;let u,a;this.stateFull&&(this.stateBackward==e?u=this.stateTriangle:(this.stateBackward=e,this.stateTriangle=void 0),a=d=>{this.stateTriangle=d});let f=ce(o,s,i,c,l,h,u,a);if(this.bounds&&e&&!n){const d=Yt(f);if(!_e(d,this.boundsPolygon))return!1}else this.yaxisMode==kt.YAXIS_FOLLOW&&!e&&(f=[f[0],-1*f[1]]);return f}};it(_t,"VERTEX_PLAIN","plain"),it(_t,"VERTEX_BIRDEYE","birdeye"),it(_t,"MODE_STRICT","strict"),it(_t,"MODE_AUTO","auto"),it(_t,"MODE_LOOSE","loose"),it(_t,"STATUS_STRICT","strict"),it(_t,"STATUS_ERROR","strict_error"),it(_t,"STATUS_LOOSE","loose"),it(_t,"YAXIS_FOLLOW","follow"),it(_t,"YAXIS_INVERT","invert");let Tn=_t;const dt=11102230246251565e-32,B=134217729,tn=(3+8*dt)*dt;function at(r,t,e,n,o){let s,i,c,l,h=t[0],u=n[0],a=0,f=0;u>h==u>-h?(s=h,h=t[++a]):(s=u,u=n[++f]);let d=0;if(a<r&&f<e)for(u>h==u>-h?(i=h+s,c=s-(i-h),h=t[++a]):(i=u+s,c=s-(i-u),u=n[++f]),s=i,c!==0&&(o[d++]=c);a<r&&f<e;)u>h==u>-h?(i=s+h,l=i-s,c=s-(i-l)+(h-l),h=t[++a]):(i=s+u,l=i-s,c=s-(i-l)+(u-l),u=n[++f]),s=i,c!==0&&(o[d++]=c);for(;a<r;)i=s+h,l=i-s,c=s-(i-l)+(h-l),h=t[++a],s=i,c!==0&&(o[d++]=c);for(;f<e;)i=s+u,l=i-s,c=s-(i-l)+(u-l),u=n[++f],s=i,c!==0&&(o[d++]=c);return(s!==0||d===0)&&(o[d++]=s),d}function yt(r,t,e,n,o,s,i,c){return at(at(r,t,e,n,i),i,o,s,c)}function A(r,t,e,n){let o,s,i,c,l,h,u,a,f,d,m;u=B*e,d=u-(u-e),m=e-d;let g=t[0];o=g*e,u=B*g,a=u-(u-g),f=g-a,i=f*m-(o-a*d-f*d-a*m);let b=0;i!==0&&(n[b++]=i);for(let w=1;w<r;w++)g=t[w],c=g*e,u=B*g,a=u-(u-g),f=g-a,l=f*m-(c-a*d-f*d-a*m),s=o+l,h=s-o,i=o-(s-h)+(l-h),i!==0&&(n[b++]=i),o=c+s,i=s-(o-c),i!==0&&(n[b++]=i);return(o!==0||b===0)&&(n[b++]=o),b}function en(r,t){let e=t[0];for(let n=1;n<r;n++)e+=t[n];return e}function H(r){return new Float64Array(r)}const Nn=(3+16*dt)*dt,Cn=(2+12*dt)*dt,Rn=(9+64*dt)*dt*dt,zt=H(4),Pe=H(8),Ue=H(12),je=H(16),pt=H(4);function Bn(r,t,e,n,o,s,i){let c,l,h,u,a,f,d,m,g,b,w,S,v,O,R,N,U,X;const E=r-o,V=e-o,L=t-s,z=n-s;O=E*z,f=B*E,d=f-(f-E),m=E-d,f=B*z,g=f-(f-z),b=z-g,R=m*b-(O-d*g-m*g-d*b),N=L*V,f=B*L,d=f-(f-L),m=L-d,f=B*V,g=f-(f-V),b=V-g,U=m*b-(N-d*g-m*g-d*b),w=R-U,a=R-w,zt[0]=R-(w+a)+(a-U),S=O+w,a=S-O,v=O-(S-a)+(w-a),w=v-N,a=v-w,zt[1]=v-(w+a)+(a-N),X=S+w,a=X-S,zt[2]=S-(X-a)+(w-a),zt[3]=X;let W=en(4,zt),p=Cn*i;if(W>=p||-W>=p||(a=r-E,c=r-(E+a)+(a-o),a=e-V,h=e-(V+a)+(a-o),a=t-L,l=t-(L+a)+(a-s),a=n-z,u=n-(z+a)+(a-s),c===0&&l===0&&h===0&&u===0)||(p=Rn*i+tn*Math.abs(W),W+=E*u+z*c-(L*h+V*l),W>=p||-W>=p))return W;O=c*z,f=B*c,d=f-(f-c),m=c-d,f=B*z,g=f-(f-z),b=z-g,R=m*b-(O-d*g-m*g-d*b),N=l*V,f=B*l,d=f-(f-l),m=l-d,f=B*V,g=f-(f-V),b=V-g,U=m*b-(N-d*g-m*g-d*b),w=R-U,a=R-w,pt[0]=R-(w+a)+(a-U),S=O+w,a=S-O,v=O-(S-a)+(w-a),w=v-N,a=v-w,pt[1]=v-(w+a)+(a-N),X=S+w,a=X-S,pt[2]=S-(X-a)+(w-a),pt[3]=X;const y=at(4,zt,4,pt,Pe);O=E*u,f=B*E,d=f-(f-E),m=E-d,f=B*u,g=f-(f-u),b=u-g,R=m*b-(O-d*g-m*g-d*b),N=L*h,f=B*L,d=f-(f-L),m=L-d,f=B*h,g=f-(f-h),b=h-g,U=m*b-(N-d*g-m*g-d*b),w=R-U,a=R-w,pt[0]=R-(w+a)+(a-U),S=O+w,a=S-O,v=O-(S-a)+(w-a),w=v-N,a=v-w,pt[1]=v-(w+a)+(a-N),X=S+w,a=X-S,pt[2]=S-(X-a)+(w-a),pt[3]=X;const _=at(y,Pe,4,pt,Ue);O=c*u,f=B*c,d=f-(f-c),m=c-d,f=B*u,g=f-(f-u),b=u-g,R=m*b-(O-d*g-m*g-d*b),N=l*h,f=B*l,d=f-(f-l),m=l-d,f=B*h,g=f-(f-h),b=h-g,U=m*b-(N-d*g-m*g-d*b),w=R-U,a=R-w,pt[0]=R-(w+a)+(a-U),S=O+w,a=S-O,v=O-(S-a)+(w-a),w=v-N,a=v-w,pt[1]=v-(w+a)+(a-N),X=S+w,a=X-S,pt[2]=S-(X-a)+(w-a),pt[3]=X;const x=at(_,Ue,4,pt,je);return je[x-1]}function Ot(r,t,e,n,o,s){const i=(t-s)*(e-o),c=(r-o)*(n-s),l=i-c,h=Math.abs(i+c);return Math.abs(l)>=Nn*h?l:-Bn(r,t,e,n,o,s,h)}const Pn=(10+96*dt)*dt,Un=(4+48*dt)*dt,jn=(44+576*dt)*dt*dt,Nt=H(4),Ct=H(4),Rt=H(4),xt=H(4),St=H(4),Mt=H(4),wt=H(4),mt=H(4),ue=H(8),de=H(8),ge=H(8),pe=H(8),we=H(8),me=H(8),te=H(8),ee=H(8),ne=H(8),Ut=H(4),jt=H(4),Dt=H(4),P=H(8),q=H(16),nt=H(16),st=H(16),et=H(32),Bt=H(32),ot=H(48),bt=H(64);let qt=H(1152),be=H(1152);function rt(r,t,e){r=at(r,qt,t,e,be);const n=qt;return qt=be,be=n,r}function Dn(r,t,e,n,o,s,i,c,l){let h,u,a,f,d,m,g,b,w,S,v,O,R,N,U,X,E,V,L,z,W,p,y,_,x,M,T,k,I,j,C,D,$,Y,F;const J=r-i,K=e-i,Q=o-i,Z=t-c,G=n-c,tt=s-c;C=K*tt,y=B*K,_=y-(y-K),x=K-_,y=B*tt,M=y-(y-tt),T=tt-M,D=x*T-(C-_*M-x*M-_*T),$=Q*G,y=B*Q,_=y-(y-Q),x=Q-_,y=B*G,M=y-(y-G),T=G-M,Y=x*T-($-_*M-x*M-_*T),k=D-Y,p=D-k,Nt[0]=D-(k+p)+(p-Y),I=C+k,p=I-C,j=C-(I-p)+(k-p),k=j-$,p=j-k,Nt[1]=j-(k+p)+(p-$),F=I+k,p=F-I,Nt[2]=I-(F-p)+(k-p),Nt[3]=F,C=Q*Z,y=B*Q,_=y-(y-Q),x=Q-_,y=B*Z,M=y-(y-Z),T=Z-M,D=x*T-(C-_*M-x*M-_*T),$=J*tt,y=B*J,_=y-(y-J),x=J-_,y=B*tt,M=y-(y-tt),T=tt-M,Y=x*T-($-_*M-x*M-_*T),k=D-Y,p=D-k,Ct[0]=D-(k+p)+(p-Y),I=C+k,p=I-C,j=C-(I-p)+(k-p),k=j-$,p=j-k,Ct[1]=j-(k+p)+(p-$),F=I+k,p=F-I,Ct[2]=I-(F-p)+(k-p),Ct[3]=F,C=J*G,y=B*J,_=y-(y-J),x=J-_,y=B*G,M=y-(y-G),T=G-M,D=x*T-(C-_*M-x*M-_*T),$=K*Z,y=B*K,_=y-(y-K),x=K-_,y=B*Z,M=y-(y-Z),T=Z-M,Y=x*T-($-_*M-x*M-_*T),k=D-Y,p=D-k,Rt[0]=D-(k+p)+(p-Y),I=C+k,p=I-C,j=C-(I-p)+(k-p),k=j-$,p=j-k,Rt[1]=j-(k+p)+(p-$),F=I+k,p=F-I,Rt[2]=I-(F-p)+(k-p),Rt[3]=F,h=at(at(at(A(A(4,Nt,J,P),P,J,q),q,A(A(4,Nt,Z,P),P,Z,nt),nt,et),et,at(A(A(4,Ct,K,P),P,K,q),q,A(A(4,Ct,G,P),P,G,nt),nt,Bt),Bt,bt),bt,at(A(A(4,Rt,Q,P),P,Q,q),q,A(A(4,Rt,tt,P),P,tt,nt),nt,et),et,qt);let vt=en(h,qt),Xt=Un*l;if(vt>=Xt||-vt>=Xt||(p=r-J,u=r-(J+p)+(p-i),p=t-Z,d=t-(Z+p)+(p-c),p=e-K,a=e-(K+p)+(p-i),p=n-G,m=n-(G+p)+(p-c),p=o-Q,f=o-(Q+p)+(p-i),p=s-tt,g=s-(tt+p)+(p-c),u===0&&a===0&&f===0&&d===0&&m===0&&g===0)||(Xt=jn*l+tn*Math.abs(vt),vt+=(J*J+Z*Z)*(K*g+tt*a-(G*f+Q*m))+2*(J*u+Z*d)*(K*tt-G*Q)+((K*K+G*G)*(Q*d+Z*f-(tt*u+J*g))+2*(K*a+G*m)*(Q*Z-tt*J))+((Q*Q+tt*tt)*(J*m+G*u-(Z*a+K*d))+2*(Q*f+tt*g)*(J*G-Z*K)),vt>=Xt||-vt>=Xt))return vt;if((a!==0||m!==0||f!==0||g!==0)&&(C=J*J,y=B*J,_=y-(y-J),x=J-_,D=x*x-(C-_*_-(_+_)*x),$=Z*Z,y=B*Z,_=y-(y-Z),x=Z-_,Y=x*x-($-_*_-(_+_)*x),k=D+Y,p=k-D,xt[0]=D-(k-p)+(Y-p),I=C+k,p=I-C,j=C-(I-p)+(k-p),k=j+$,p=k-j,xt[1]=j-(k-p)+($-p),F=I+k,p=F-I,xt[2]=I-(F-p)+(k-p),xt[3]=F),(f!==0||g!==0||u!==0||d!==0)&&(C=K*K,y=B*K,_=y-(y-K),x=K-_,D=x*x-(C-_*_-(_+_)*x),$=G*G,y=B*G,_=y-(y-G),x=G-_,Y=x*x-($-_*_-(_+_)*x),k=D+Y,p=k-D,St[0]=D-(k-p)+(Y-p),I=C+k,p=I-C,j=C-(I-p)+(k-p),k=j+$,p=k-j,St[1]=j-(k-p)+($-p),F=I+k,p=F-I,St[2]=I-(F-p)+(k-p),St[3]=F),(u!==0||d!==0||a!==0||m!==0)&&(C=Q*Q,y=B*Q,_=y-(y-Q),x=Q-_,D=x*x-(C-_*_-(_+_)*x),$=tt*tt,y=B*tt,_=y-(y-tt),x=tt-_,Y=x*x-($-_*_-(_+_)*x),k=D+Y,p=k-D,Mt[0]=D-(k-p)+(Y-p),I=C+k,p=I-C,j=C-(I-p)+(k-p),k=j+$,p=k-j,Mt[1]=j-(k-p)+($-p),F=I+k,p=F-I,Mt[2]=I-(F-p)+(k-p),Mt[3]=F),u!==0&&(b=A(4,Nt,u,ue),h=rt(h,yt(A(b,ue,2*J,q),q,A(A(4,Mt,u,P),P,G,nt),nt,A(A(4,St,u,P),P,-tt,st),st,et,ot),ot)),d!==0&&(w=A(4,Nt,d,de),h=rt(h,yt(A(w,de,2*Z,q),q,A(A(4,St,d,P),P,Q,nt),nt,A(A(4,Mt,d,P),P,-K,st),st,et,ot),ot)),a!==0&&(S=A(4,Ct,a,ge),h=rt(h,yt(A(S,ge,2*K,q),q,A(A(4,xt,a,P),P,tt,nt),nt,A(A(4,Mt,a,P),P,-Z,st),st,et,ot),ot)),m!==0&&(v=A(4,Ct,m,pe),h=rt(h,yt(A(v,pe,2*G,q),q,A(A(4,Mt,m,P),P,J,nt),nt,A(A(4,xt,m,P),P,-Q,st),st,et,ot),ot)),f!==0&&(O=A(4,Rt,f,we),h=rt(h,yt(A(O,we,2*Q,q),q,A(A(4,St,f,P),P,Z,nt),nt,A(A(4,xt,f,P),P,-G,st),st,et,ot),ot)),g!==0&&(R=A(4,Rt,g,me),h=rt(h,yt(A(R,me,2*tt,q),q,A(A(4,xt,g,P),P,K,nt),nt,A(A(4,St,g,P),P,-J,st),st,et,ot),ot)),u!==0||d!==0){if(a!==0||m!==0||f!==0||g!==0?(C=a*tt,y=B*a,_=y-(y-a),x=a-_,y=B*tt,M=y-(y-tt),T=tt-M,D=x*T-(C-_*M-x*M-_*T),$=K*g,y=B*K,_=y-(y-K),x=K-_,y=B*g,M=y-(y-g),T=g-M,Y=x*T-($-_*M-x*M-_*T),k=D+Y,p=k-D,wt[0]=D-(k-p)+(Y-p),I=C+k,p=I-C,j=C-(I-p)+(k-p),k=j+$,p=k-j,wt[1]=j-(k-p)+($-p),F=I+k,p=F-I,wt[2]=I-(F-p)+(k-p),wt[3]=F,C=f*-G,y=B*f,_=y-(y-f),x=f-_,y=B*-G,M=y-(y- -G),T=-G-M,D=x*T-(C-_*M-x*M-_*T),$=Q*-m,y=B*Q,_=y-(y-Q),x=Q-_,y=B*-m,M=y-(y- -m),T=-m-M,Y=x*T-($-_*M-x*M-_*T),k=D+Y,p=k-D,mt[0]=D-(k-p)+(Y-p),I=C+k,p=I-C,j=C-(I-p)+(k-p),k=j+$,p=k-j,mt[1]=j-(k-p)+($-p),F=I+k,p=F-I,mt[2]=I-(F-p)+(k-p),mt[3]=F,U=at(4,wt,4,mt,ee),C=a*g,y=B*a,_=y-(y-a),x=a-_,y=B*g,M=y-(y-g),T=g-M,D=x*T-(C-_*M-x*M-_*T),$=f*m,y=B*f,_=y-(y-f),x=f-_,y=B*m,M=y-(y-m),T=m-M,Y=x*T-($-_*M-x*M-_*T),k=D-Y,p=D-k,jt[0]=D-(k+p)+(p-Y),I=C+k,p=I-C,j=C-(I-p)+(k-p),k=j-$,p=j-k,jt[1]=j-(k+p)+(p-$),F=I+k,p=F-I,jt[2]=I-(F-p)+(k-p),jt[3]=F,V=4):(ee[0]=0,U=1,jt[0]=0,V=1),u!==0){const lt=A(U,ee,u,st);h=rt(h,at(A(b,ue,u,q),q,A(lt,st,2*J,et),et,ot),ot);const ft=A(V,jt,u,P);h=rt(h,yt(A(ft,P,2*J,q),q,A(ft,P,u,nt),nt,A(lt,st,u,et),et,Bt,bt),bt),m!==0&&(h=rt(h,A(A(4,Mt,u,P),P,m,q),q)),g!==0&&(h=rt(h,A(A(4,St,-u,P),P,g,q),q))}if(d!==0){const lt=A(U,ee,d,st);h=rt(h,at(A(w,de,d,q),q,A(lt,st,2*Z,et),et,ot),ot);const ft=A(V,jt,d,P);h=rt(h,yt(A(ft,P,2*Z,q),q,A(ft,P,d,nt),nt,A(lt,st,d,et),et,Bt,bt),bt)}}if(a!==0||m!==0){if(f!==0||g!==0||u!==0||d!==0?(C=f*Z,y=B*f,_=y-(y-f),x=f-_,y=B*Z,M=y-(y-Z),T=Z-M,D=x*T-(C-_*M-x*M-_*T),$=Q*d,y=B*Q,_=y-(y-Q),x=Q-_,y=B*d,M=y-(y-d),T=d-M,Y=x*T-($-_*M-x*M-_*T),k=D+Y,p=k-D,wt[0]=D-(k-p)+(Y-p),I=C+k,p=I-C,j=C-(I-p)+(k-p),k=j+$,p=k-j,wt[1]=j-(k-p)+($-p),F=I+k,p=F-I,wt[2]=I-(F-p)+(k-p),wt[3]=F,z=-tt,W=-g,C=u*z,y=B*u,_=y-(y-u),x=u-_,y=B*z,M=y-(y-z),T=z-M,D=x*T-(C-_*M-x*M-_*T),$=J*W,y=B*J,_=y-(y-J),x=J-_,y=B*W,M=y-(y-W),T=W-M,Y=x*T-($-_*M-x*M-_*T),k=D+Y,p=k-D,mt[0]=D-(k-p)+(Y-p),I=C+k,p=I-C,j=C-(I-p)+(k-p),k=j+$,p=k-j,mt[1]=j-(k-p)+($-p),F=I+k,p=F-I,mt[2]=I-(F-p)+(k-p),mt[3]=F,X=at(4,wt,4,mt,ne),C=f*d,y=B*f,_=y-(y-f),x=f-_,y=B*d,M=y-(y-d),T=d-M,D=x*T-(C-_*M-x*M-_*T),$=u*g,y=B*u,_=y-(y-u),x=u-_,y=B*g,M=y-(y-g),T=g-M,Y=x*T-($-_*M-x*M-_*T),k=D-Y,p=D-k,Dt[0]=D-(k+p)+(p-Y),I=C+k,p=I-C,j=C-(I-p)+(k-p),k=j-$,p=j-k,Dt[1]=j-(k+p)+(p-$),F=I+k,p=F-I,Dt[2]=I-(F-p)+(k-p),Dt[3]=F,L=4):(ne[0]=0,X=1,Dt[0]=0,L=1),a!==0){const lt=A(X,ne,a,st);h=rt(h,at(A(S,ge,a,q),q,A(lt,st,2*K,et),et,ot),ot);const ft=A(L,Dt,a,P);h=rt(h,yt(A(ft,P,2*K,q),q,A(ft,P,a,nt),nt,A(lt,st,a,et),et,Bt,bt),bt),g!==0&&(h=rt(h,A(A(4,xt,a,P),P,g,q),q)),d!==0&&(h=rt(h,A(A(4,Mt,-a,P),P,d,q),q))}if(m!==0){const lt=A(X,ne,m,st);h=rt(h,at(A(v,pe,m,q),q,A(lt,st,2*G,et),et,ot),ot);const ft=A(L,Dt,m,P);h=rt(h,yt(A(ft,P,2*G,q),q,A(ft,P,m,nt),nt,A(lt,st,m,et),et,Bt,bt),bt)}}if(f!==0||g!==0){if(u!==0||d!==0||a!==0||m!==0?(C=u*G,y=B*u,_=y-(y-u),x=u-_,y=B*G,M=y-(y-G),T=G-M,D=x*T-(C-_*M-x*M-_*T),$=J*m,y=B*J,_=y-(y-J),x=J-_,y=B*m,M=y-(y-m),T=m-M,Y=x*T-($-_*M-x*M-_*T),k=D+Y,p=k-D,wt[0]=D-(k-p)+(Y-p),I=C+k,p=I-C,j=C-(I-p)+(k-p),k=j+$,p=k-j,wt[1]=j-(k-p)+($-p),F=I+k,p=F-I,wt[2]=I-(F-p)+(k-p),wt[3]=F,z=-Z,W=-d,C=a*z,y=B*a,_=y-(y-a),x=a-_,y=B*z,M=y-(y-z),T=z-M,D=x*T-(C-_*M-x*M-_*T),$=K*W,y=B*K,_=y-(y-K),x=K-_,y=B*W,M=y-(y-W),T=W-M,Y=x*T-($-_*M-x*M-_*T),k=D+Y,p=k-D,mt[0]=D-(k-p)+(Y-p),I=C+k,p=I-C,j=C-(I-p)+(k-p),k=j+$,p=k-j,mt[1]=j-(k-p)+($-p),F=I+k,p=F-I,mt[2]=I-(F-p)+(k-p),mt[3]=F,N=at(4,wt,4,mt,te),C=u*m,y=B*u,_=y-(y-u),x=u-_,y=B*m,M=y-(y-m),T=m-M,D=x*T-(C-_*M-x*M-_*T),$=a*d,y=B*a,_=y-(y-a),x=a-_,y=B*d,M=y-(y-d),T=d-M,Y=x*T-($-_*M-x*M-_*T),k=D-Y,p=D-k,Ut[0]=D-(k+p)+(p-Y),I=C+k,p=I-C,j=C-(I-p)+(k-p),k=j-$,p=j-k,Ut[1]=j-(k+p)+(p-$),F=I+k,p=F-I,Ut[2]=I-(F-p)+(k-p),Ut[3]=F,E=4):(te[0]=0,N=1,Ut[0]=0,E=1),f!==0){const lt=A(N,te,f,st);h=rt(h,at(A(O,we,f,q),q,A(lt,st,2*Q,et),et,ot),ot);const ft=A(E,Ut,f,P);h=rt(h,yt(A(ft,P,2*Q,q),q,A(ft,P,f,nt),nt,A(lt,st,f,et),et,Bt,bt),bt),d!==0&&(h=rt(h,A(A(4,St,f,P),P,d,q),q)),m!==0&&(h=rt(h,A(A(4,xt,-f,P),P,m,q),q))}if(g!==0){const lt=A(N,te,g,st);h=rt(h,at(A(R,me,g,q),q,A(lt,st,2*tt,et),et,ot),ot);const ft=A(E,Ut,g,P);h=rt(h,yt(A(ft,P,2*tt,q),q,A(ft,P,g,nt),nt,A(lt,st,g,et),et,Bt,bt),bt)}}return qt[h-1]}function $n(r,t,e,n,o,s,i,c){const l=r-i,h=e-i,u=o-i,a=t-c,f=n-c,d=s-c,m=h*d,g=u*f,b=l*l+a*a,w=u*a,S=l*d,v=h*h+f*f,O=l*f,R=h*a,N=u*u+d*d,U=b*(m-g)+v*(w-S)+N*(O-R),X=(Math.abs(m)+Math.abs(g))*b+(Math.abs(w)+Math.abs(S))*v+(Math.abs(O)+Math.abs(R))*N,E=Pn*X;return U>E||-U>E?U:Dn(r,t,e,n,o,s,i,c,X)}const De=Math.pow(2,-52),se=new Uint32Array(512);class xe{static from(t,e=qn,n=Xn){const o=t.length,s=new Float64Array(o*2);for(let i=0;i<o;i++){const c=t[i];s[2*i]=e(c),s[2*i+1]=n(c)}return new xe(s)}constructor(t){const e=t.length>>1;if(e>0&&typeof t[0]!="number")throw new Error("Expected coords to contain numbers.");this.coords=t;const n=Math.max(2*e-5,0);this._triangles=new Uint32Array(n*3),this._halfedges=new Int32Array(n*3),this._hashSize=Math.ceil(Math.sqrt(e)),this._hullPrev=new Uint32Array(e),this._hullNext=new Uint32Array(e),this._hullTri=new Uint32Array(e),this._hullHash=new Int32Array(this._hashSize),this._ids=new Uint32Array(e),this._dists=new Float64Array(e),this.update()}update(){const{coords:t,_hullPrev:e,_hullNext:n,_hullTri:o,_hullHash:s}=this,i=t.length>>1;let c=1/0,l=1/0,h=-1/0,u=-1/0;for(let E=0;E<i;E++){const V=t[2*E],L=t[2*E+1];V<c&&(c=V),L<l&&(l=L),V>h&&(h=V),L>u&&(u=L),this._ids[E]=E}const a=(c+h)/2,f=(l+u)/2;let d,m,g;for(let E=0,V=1/0;E<i;E++){const L=ye(a,f,t[2*E],t[2*E+1]);L<V&&(d=E,V=L)}const b=t[2*d],w=t[2*d+1];for(let E=0,V=1/0;E<i;E++){if(E===d)continue;const L=ye(b,w,t[2*E],t[2*E+1]);L<V&&L>0&&(m=E,V=L)}let S=t[2*m],v=t[2*m+1],O=1/0;for(let E=0;E<i;E++){if(E===d||E===m)continue;const V=zn(b,w,S,v,t[2*E],t[2*E+1]);V<O&&(g=E,O=V)}let R=t[2*g],N=t[2*g+1];if(O===1/0){for(let L=0;L<i;L++)this._dists[L]=t[2*L]-t[0]||t[2*L+1]-t[1];Vt(this._ids,this._dists,0,i-1);const E=new Uint32Array(i);let V=0;for(let L=0,z=-1/0;L<i;L++){const W=this._ids[L],p=this._dists[W];p>z&&(E[V++]=W,z=p)}this.hull=E.subarray(0,V),this.triangles=new Uint32Array(0),this.halfedges=new Uint32Array(0);return}if(Ot(b,w,S,v,R,N)<0){const E=m,V=S,L=v;m=g,S=R,v=N,g=E,R=V,N=L}const U=Vn(b,w,S,v,R,N);this._cx=U.x,this._cy=U.y;for(let E=0;E<i;E++)this._dists[E]=ye(t[2*E],t[2*E+1],U.x,U.y);Vt(this._ids,this._dists,0,i-1),this._hullStart=d;let X=3;n[d]=e[g]=m,n[m]=e[d]=g,n[g]=e[m]=d,o[d]=0,o[m]=1,o[g]=2,s.fill(-1),s[this._hashKey(b,w)]=d,s[this._hashKey(S,v)]=m,s[this._hashKey(R,N)]=g,this.trianglesLen=0,this._addTriangle(d,m,g,-1,-1,-1);for(let E=0,V,L;E<this._ids.length;E++){const z=this._ids[E],W=t[2*z],p=t[2*z+1];if(E>0&&Math.abs(W-V)<=De&&Math.abs(p-L)<=De||(V=W,L=p,z===d||z===m||z===g))continue;let y=0;for(let k=0,I=this._hashKey(W,p);k<this._hashSize&&(y=s[(I+k)%this._hashSize],!(y!==-1&&y!==n[y]));k++);y=e[y];let _=y,x;for(;x=n[_],Ot(W,p,t[2*_],t[2*_+1],t[2*x],t[2*x+1])>=0;)if(_=x,_===y){_=-1;break}if(_===-1)continue;let M=this._addTriangle(_,z,n[_],-1,-1,o[_]);o[z]=this._legalize(M+2),o[_]=M,X++;let T=n[_];for(;x=n[T],Ot(W,p,t[2*T],t[2*T+1],t[2*x],t[2*x+1])<0;)M=this._addTriangle(T,z,x,o[z],-1,o[T]),o[z]=this._legalize(M+2),n[T]=T,X--,T=x;if(_===y)for(;x=e[_],Ot(W,p,t[2*x],t[2*x+1],t[2*_],t[2*_+1])<0;)M=this._addTriangle(x,z,_,-1,o[_],o[x]),this._legalize(M+2),o[x]=M,n[_]=_,X--,_=x;this._hullStart=e[z]=_,n[_]=e[T]=z,n[z]=T,s[this._hashKey(W,p)]=z,s[this._hashKey(t[2*_],t[2*_+1])]=_}this.hull=new Uint32Array(X);for(let E=0,V=this._hullStart;E<X;E++)this.hull[E]=V,V=n[V];this.triangles=this._triangles.subarray(0,this.trianglesLen),this.halfedges=this._halfedges.subarray(0,this.trianglesLen)}_hashKey(t,e){return Math.floor(Fn(t-this._cx,e-this._cy)*this._hashSize)%this._hashSize}_legalize(t){const{_triangles:e,_halfedges:n,coords:o}=this;let s=0,i=0;for(;;){const c=n[t],l=t-t%3;if(i=l+(t+2)%3,c===-1){if(s===0)break;t=se[--s];continue}const h=c-c%3,u=l+(t+1)%3,a=h+(c+2)%3,f=e[i],d=e[t],m=e[u],g=e[a];if(Ln(o[2*f],o[2*f+1],o[2*d],o[2*d+1],o[2*m],o[2*m+1],o[2*g],o[2*g+1])){e[t]=g,e[c]=f;const w=n[a];if(w===-1){let v=this._hullStart;do{if(this._hullTri[v]===a){this._hullTri[v]=t;break}v=this._hullPrev[v]}while(v!==this._hullStart)}this._link(t,w),this._link(c,n[i]),this._link(i,a);const S=h+(c+1)%3;s<se.length&&(se[s++]=S)}else{if(s===0)break;t=se[--s]}}return i}_link(t,e){this._halfedges[t]=e,e!==-1&&(this._halfedges[e]=t)}_addTriangle(t,e,n,o,s,i){const c=this.trianglesLen;return this._triangles[c]=t,this._triangles[c+1]=e,this._triangles[c+2]=n,this._link(c,o),this._link(c+1,s),this._link(c+2,i),this.trianglesLen+=3,c}}function Fn(r,t){const e=r/(Math.abs(r)+Math.abs(t));return(t>0?3-e:1+e)/4}function ye(r,t,e,n){const o=r-e,s=t-n;return o*o+s*s}function Ln(r,t,e,n,o,s,i,c){const l=r-i,h=t-c,u=e-i,a=n-c,f=o-i,d=s-c,m=l*l+h*h,g=u*u+a*a,b=f*f+d*d;return l*(a*b-g*d)-h*(u*b-g*f)+m*(u*d-a*f)<0}function zn(r,t,e,n,o,s){const i=e-r,c=n-t,l=o-r,h=s-t,u=i*i+c*c,a=l*l+h*h,f=.5/(i*h-c*l),d=(h*u-c*a)*f,m=(i*a-l*u)*f;return d*d+m*m}function Vn(r,t,e,n,o,s){const i=e-r,c=n-t,l=o-r,h=s-t,u=i*i+c*c,a=l*l+h*h,f=.5/(i*h-c*l),d=r+(h*u-c*a)*f,m=t+(i*a-l*u)*f;return{x:d,y:m}}function Vt(r,t,e,n){if(n-e<=20)for(let o=e+1;o<=n;o++){const s=r[o],i=t[s];let c=o-1;for(;c>=e&&t[r[c]]>i;)r[c+1]=r[c--];r[c+1]=s}else{const o=e+n>>1;let s=e+1,i=n;Wt(r,o,s),t[r[e]]>t[r[n]]&&Wt(r,e,n),t[r[s]]>t[r[n]]&&Wt(r,s,n),t[r[e]]>t[r[s]]&&Wt(r,e,s);const c=r[s],l=t[c];for(;;){do s++;while(t[r[s]]<l);do i--;while(t[r[i]]>l);if(i<s)break;Wt(r,s,i)}r[e+1]=r[i],r[i]=c,n-s+1>=i-e?(Vt(r,t,s,n),Vt(r,t,e,i-1)):(Vt(r,t,e,i-1),Vt(r,t,s,n))}}function Wt(r,t,e){const n=r[t];r[t]=r[e],r[e]=n}function qn(r){return r[0]}function Xn(r){return r[1]}class Yn{bs;width;constructor(t,e){this.width=t,this.bs=e}add(t){const e=Math.floor(t/this.width),n=t%this.width;return this.bs[e]|=1<<n,this}delete(t){const e=Math.floor(t/this.width),n=t%this.width;return this.bs[e]&=~(1<<n),this}set(t,e){const n=Math.floor(t/this.width),s=1<<t%this.width;return this.bs[n]^=(-Number(e)^this.bs[n])&s,e}has(t){const e=Math.floor(t/this.width),n=t%this.width;return(this.bs[e]&1<<n)!==0}forEach(t){const e=this.bs.length;for(let n=0;n<e;n++){let o=0;for(;this.bs[n]&&o<this.width;)this.bs[n]&1<<o&&t(n*this.width+o),o++}return this}}class $e extends Yn{constructor(t){super(8,new Uint8Array(Math.ceil(t/8)).fill(0))}}function $t(r){return r%3===2?r-2:r+1}function Et(r){return r%3===0?r+2:r-1}function Fe(r,t,e,n,o,s,i,c){const l=Ot(r,t,o,s,i,c),h=Ot(e,n,o,s,i,c);if(l>0&&h>0||l<0&&h<0)return!1;const u=Ot(o,s,r,t,e,n),a=Ot(i,c,r,t,e,n);return u>0&&a>0||u<0&&a<0?!1:l===0&&h===0&&u===0&&a===0?!(Math.max(o,i)<Math.min(r,e)||Math.max(r,e)<Math.min(o,i)||Math.max(s,c)<Math.min(t,n)||Math.max(t,n)<Math.min(s,c)):!0}class Wn{del;constructor(t){this.del=t}}class Jn extends Wn{vertMap;flips;consd;constructor(t,e){if(!t||typeof t!="object"||!t.triangles||!t.halfedges||!t.coords)throw new Error("Expected an object with Delaunator output");if(t.triangles.length%3||t.halfedges.length!==t.triangles.length||t.coords.length%2)throw new Error("Delaunator output appears inconsistent");if(t.triangles.length<3)throw new Error("No edges in triangulation");super(t);const n=2**32-1,o=t.coords.length>>1,s=t.triangles.length;this.vertMap=new Uint32Array(o).fill(n),this.flips=new $e(s),this.consd=new $e(s);for(let i=0;i<s;i++){const c=t.triangles[i];this.vertMap[c]===n&&this.updateVert(i)}e&&this.constrainAll(e)}constrainOne(t,e){const{triangles:n,halfedges:o}=this.del,s=this.vertMap[t];let i=s;do{const h=n[i],u=$t(i);if(h===e)return this.protect(i);const a=Et(i),f=n[a];if(f===e)return this.protect(u),u;if(this.intersectSegments(t,e,f,h)){i=a;break}i=o[u]}while(i!==-1&&i!==s);let c=i,l=-1;for(;i!==-1;){const h=o[i],u=Et(i),a=Et(h),f=$t(h);if(h===-1)throw new Error("Constraining edge exited the hull");if(this.consd.has(i))throw new Error("Edge intersects already constrained edge");if(this.isCollinear(t,e,n[i])||this.isCollinear(t,e,n[h]))throw new Error("Constraining edge intersects point");if(!this.intersectSegments(n[i],n[h],n[u],n[a])){if(l===-1&&(l=i),n[a]===e){if(i===l)throw new Error("Infinite loop: non-convex quadrilateral");i=l,l=-1;continue}if(this.intersectSegments(t,e,n[a],n[h]))i=a;else if(this.intersectSegments(t,e,n[f],n[a]))i=f;else if(l===i)throw new Error("Infinite loop: no further intersect after non-convex");continue}if(this.flipDiagonal(i),this.intersectSegments(t,e,n[u],n[a])&&(l===-1&&(l=u),l===u))throw new Error("Infinite loop: flipped diagonal still intersects");n[a]===e?(c=a,i=l,l=-1):this.intersectSegments(t,e,n[f],n[a])&&(i=f)}return this.protect(c),this.delaunify(!0),this.findEdge(t,e)}delaunify(t=!1){const{halfedges:e}=this.del,n=this.flips,o=this.consd,s=e.length;let i;do{i=0;for(let c=0;c<s;c++){if(o.has(c))continue;n.delete(c);const l=e[c];l!==-1&&(n.delete(l),this.isDelaunay(c)||(this.flipDiagonal(c),i++))}}while(t&&i>0);return this}constrainAll(t){const e=t.length;for(let n=0;n<e;n++){const o=t[n];this.constrainOne(o[0],o[1])}return this}isConstrained(t){return this.consd.has(t)}findEdge(t,e){const n=this.vertMap[e],{triangles:o,halfedges:s}=this.del;let i=n,c=-1;do{if(o[i]===t)return i;c=$t(i),i=s[c]}while(i!==-1&&i!==n);return o[$t(c)]===t?-c:1/0}protect(t){const e=this.del.halfedges[t],n=this.flips,o=this.consd;return n.delete(t),o.add(t),e!==-1?(n.delete(e),o.add(e),e):-t}markFlip(t){const e=this.del.halfedges,n=this.flips;if(this.consd.has(t))return!1;const s=e[t];return s!==-1&&(n.add(t),n.add(s)),!0}flipDiagonal(t){const{triangles:e,halfedges:n}=this.del,o=this.flips,s=this.consd,i=n[t],c=Et(t),l=$t(t),h=Et(i),u=$t(i),a=n[c],f=n[h];if(s.has(t))throw new Error("Trying to flip a constrained edge");return e[t]=e[h],n[t]=f,o.set(t,o.has(h))||s.set(t,s.has(h)),f!==-1&&(n[f]=t),n[c]=h,e[i]=e[c],n[i]=a,o.set(i,o.has(c))||s.set(i,s.has(c)),a!==-1&&(n[a]=i),n[h]=c,this.markFlip(t),this.markFlip(l),this.markFlip(i),this.markFlip(u),o.add(c),s.delete(c),o.add(h),s.delete(h),this.updateVert(t),this.updateVert(l),this.updateVert(i),this.updateVert(u),c}isCollinear(t,e,n){const o=this.del.coords;return Ot(o[t*2],o[t*2+1],o[e*2],o[e*2+1],o[n*2],o[n*2+1])===0}inCircle(t,e,n,o){const s=this.del.coords;return $n(s[t*2],s[t*2+1],s[e*2],s[e*2+1],s[n*2],s[n*2+1],s[o*2],s[o*2+1])<0}isDelaunay(t){const{triangles:e,halfedges:n}=this.del,o=n[t];if(o===-1)return!0;const s=e[Et(t)],i=e[t],c=e[$t(t)],l=e[Et(o)];return!this.inCircle(s,i,c,l)}updateVert(t){const{triangles:e,halfedges:n}=this.del,o=this.vertMap,s=e[t];let i=Et(t),c=n[i];for(;c!==-1&&c!==t;)i=Et(c),c=n[i];return o[s]=i,i}intersectSegments(t,e,n,o){const s=this.del.coords;return t===n||t===o||e===n||e===o?!1:Fe(s[t*2],s[t*2+1],s[e*2],s[e*2+1],s[n*2],s[n*2+1],s[o*2],s[o*2+1])}static intersectSegments=Fe}function Jt(r,t,e){if(t||(t=[]),typeof r!="object"||r.type!=="FeatureCollection")throw"Argument points must be FeatureCollection";if(!Array.isArray(t))throw"Argument points must be Array of Array";const n=r.features.map(l=>l.geometry.coordinates),o=xe.from(n);let s;const i=[];o.triangles.length!==0&&t.length!==0&&(s=new Jn(o),s.constrainAll(t));for(let l=0;l<o.triangles.length;l+=3)i.push([o.triangles[l],o.triangles[l+1],o.triangles[l+2]]);const c=["a","b","c"];return ht.featureCollection(i.map(l=>{const h={},u=l.map((a,f)=>{const d=r.features[a],m=d.geometry.coordinates,g=[m[0],m[1]];return m.length===3?g[2]=m[2]:h[c[f]]=d.properties[e],g});return u[3]=u[0],ht.polygon([u],h)}))}function nn(r,t,e,n,o,s){return Object.keys(r).reduce((i,c)=>{const l=r[c],h=l.forw,u=l.bakw,a={forw:[h[0]-t.forw[0],h[1]-t.forw[1]],bakw:[u[0]-t.bakw[0],u[1]-t.bakw[1]]},f=a.forw[0]===0?1/0:((a.forw[0]<0?e:n)-t.forw[0])/a.forw[0],d=a.forw[1]===0?1/0:((a.forw[1]<0?o:s)-t.forw[1])/a.forw[1];if(Math.abs(f)/Math.abs(d)<1.1){const m={forw:[a.forw[0]*f+t.forw[0],a.forw[1]*f+t.forw[1]],bakw:[a.bakw[0]*f+t.bakw[0],a.bakw[1]*f+t.bakw[1]]};a.forw[0]<0?i[3].push(m):i[1].push(m)}if(Math.abs(d)/Math.abs(f)<1.1){const m={forw:[a.forw[0]*d+t.forw[0],a.forw[1]*d+t.forw[1]],bakw:[a.bakw[0]*d+t.bakw[0],a.bakw[1]*d+t.bakw[1]]};a.forw[1]<0?i[0].push(m):i[2].push(m)}return i},[[],[],[],[]])}function Kn(r,t){const e=[[],[],[],[]],n=[];return Object.keys(r).forEach(o=>{const s=r[o],i=s.forw,c=s.bakw,l=[i[0]-t.forw[0],i[1]-t.forw[1]],h=[c[0]-t.bakw[0],t.bakw[1]-c[1]],u={forw:l,bakw:h};if(n.push(u),l[0]===0||l[1]===0)return;let a=0;l[0]>0&&(a+=1),l[1]>0&&(a+=2),e[a].push(u)}),{perQuad:e,aggregate:n}}function Qn(r){let t=1/0,e=0,n=0;return r.forEach(o=>{const{forw:s,bakw:i}=o,c=Math.hypot(s[0],s[1]),l=Math.hypot(i[0],i[1]);if(l===0)return;const h=c/l,u=Math.atan2(s[0],s[1])-Math.atan2(i[0],i[1]);t=Math.min(t,h),e+=Math.cos(u),n+=Math.sin(u)}),isFinite(t)?[t,Math.atan2(n,e)]:[1,0]}function sn(r,t,e){const{perQuad:n,aggregate:o}=Kn(r,t),s=n.every(l=>l.length>0);let i;e==="birdeye"&&s?i=n:e==="birdeye"?i=[o]:s?i=n:i=[o];const c=i.map(l=>Qn(l));return c.length===1?[c[0],c[0],c[0],c[0]]:c}function Gn(r,t,e){const n=[1,1,1,1];for(let o=0;o<4;o++){const s=(o+1)%4,i=ht.lineString([r[o].bakw,r[s].bakw]);t[o].map(c=>{const l=ht.lineString([e.bakw,c.bakw]),h=un(i,l);if(h.features.length>0&&h.features[0].geometry){const u=h.features[0],a=Math.sqrt(Math.pow(c.bakw[0]-e.bakw[0],2)+Math.pow(c.bakw[1]-e.bakw[1],2)),f=Math.sqrt(Math.pow(u.geometry.coordinates[0]-e.bakw[0],2)+Math.pow(u.geometry.coordinates[1]-e.bakw[1],2)),d=a/f;d>n[o]&&(n[o]=d),d>n[s]&&(n[s]=d)}})}r.forEach((o,s)=>{const i=n[s],c=[(o.bakw[0]-e.bakw[0])*i+e.bakw[0],(o.bakw[1]-e.bakw[1])*i+e.bakw[1]];o.bakw=c})}function on(r,t,e,n){const o=r.map((i,c)=>{const l=t[c],h=[l[0]-e.forw[0],l[1]-e.forw[1]],a=Math.sqrt(Math.pow(h[0],2)+Math.pow(h[1],2))/i[0],f=Math.atan2(h[0],h[1])-i[1],d=[e.bakw[0]+a*Math.sin(f),e.bakw[1]-a*Math.cos(f)];return{forw:l,bakw:d}}),s=o[2];return o[2]=o[3],o[3]=s,Gn(o,n,e),o}function Hn(r){const{convexBuf:t,centroid:e,bbox:n,minx:o,maxx:s,miny:i,maxy:c}=r,l=nn(t,e,o,s,i,c),h=sn(t,e,"plain");return on(h,n,e,l)}function Zn(r){const{convexBuf:t,centroid:e,bbox:n,minx:o,maxx:s,miny:i,maxy:c}=r,l=nn(t,e,o,s,i,c),h=sn(t,e,"birdeye");return on(h,n,e,l)}function rn(r){const e=new ts(r).findSegmentIntersections();return hn(e).reduce((n,o,s,i)=>Array.isArray(n)||(n||(n={}),n[`${o.x}:${o.y}`]=o,s!=i.length-1)?n:Object.keys(n).map(c=>ht.point([n[c].x,n[c].y])),{})}class ts{_xx;_yy;_ii;_nn;_zz;_zlimit=0;_bb;_allBounds;_arcIter;_filteredArcIter;buf;constructor(t){this.initArcs(t)}initArcs(t){const e=[],n=[],o=t.map(s=>{const i=s?s.length:0;for(let c=0;c<i;c++)e.push(s[c][0]),n.push(s[c][1]);return i});this.initXYData(o,e,n)}initXYData(t,e,n){const o=t.length;this._xx=new Float64Array(e),this._yy=new Float64Array(n),this._nn=new Uint32Array(t),this._zz=null,this._zlimit=0,this._filteredArcIter=null,this._ii=new Uint32Array(o);let s=0;for(let i=0;i<o;i++)this._ii[i]=s,s+=t[i];(s!=this._xx.length||this._xx.length!=this._yy.length)&&Se("ArcCollection#initXYData() Counting error"),this.initBounds(),this._arcIter=new _s(this._xx,this._yy)}initBounds(){const t=this.calcArcBounds_(this._xx,this._yy,this._nn);this._bb=t.bb,this._allBounds=t.bounds}calcArcBounds_(t,e,n){const o=n.length,s=new Float64Array(o*4),i=new he;let c=0,l,h,u;for(let a=0;a<o;a++)l=n[a],l>0&&(h=a*4,u=ks(t,e,c,l),s[h++]=u[0],s[h++]=u[1],s[h++]=u[2],s[h]=u[3],c+=l,i.mergeBounds(u));return{bb:s,bounds:i}}getBounds(){return this._allBounds.clone()}forEachSegment(t){let e=0;for(let n=0,o=this.size();n<o;n++)e+=this.forEachArcSegment(n,t);return e}size(){return this._ii&&this._ii.length||0}forEachArcSegment(t,e){const n=t>=0,o=n?t:~t,s=this.getRetainedInterval(),i=this._nn[o],c=n?1:-1;let l=n?this._ii[o]:this._ii[o]+i-1,h=l,u=0;for(let a=1;a<i;a++)h+=c,(s===0||this._zz[h]>=s)&&(e(l,h,this._xx,this._yy),l=h,u++);return u}getRetainedInterval(){return this._zlimit}getVertexData(){return{xx:this._xx,yy:this._yy,zz:this._zz,bb:this._bb,nn:this._nn,ii:this._ii}}getUint32Array(t){const e=t*4;return(!this.buf||this.buf.byteLength<e)&&(this.buf=new ArrayBuffer(e)),new Uint32Array(this.buf,0,t)}getAvgSegment2(){let t=0,e=0;const n=this.forEachSegment((o,s,i,c)=>{t+=Math.abs(i[o]-i[s]),e+=Math.abs(c[o]-c[s])});return[t/n||0,e/n||0]}calcSegmentIntersectionStripeCount(){const t=this.getBounds().height(),e=this.getAvgSegment2()[1];let n=1;return e>0&&t>0&&(n=Math.ceil(t/e/20)),n||1}findSegmentIntersections(){const t=this.getBounds(),e=t.ymin,n=t.ymax-e,o=this.calcSegmentIntersectionStripeCount(),s=new Uint32Array(o),i=o>1?g=>Math.floor((o-1)*(g-e)/n):()=>0;let c,l;this.forEachSegment((g,b,w,S)=>{let v=i(S[g]);const O=i(S[b]);for(;s[v]=s[v]+2,v!=O;)v+=O>v?1:-1});const h=this.getUint32Array(ss(s));let u=0;const a=[];is(s,g=>{const b=u;u+=g,a.push(h.subarray(b,u))}),os(s,0),this.forEachSegment((g,b,w,S)=>{let v=i(S[g]);const O=i(S[b]);let R,N;for(;R=s[v],s[v]=R+2,N=a[v],N[R]=g,N[R+1]=b,v!=O;)v+=O>v?1:-1});const f=this.getVertexData(),d=[];let m;for(c=0;c<o;c++)for(m=rs(a[c],f.xx,f.yy),l=0;l<m.length;l++)d.push(m[l]);return hn(d)}}function Se(...r){const t=r.join(" ");throw new Error(t)}function Me(r){return r?ns(r)?!0:es(r)?!1:r.length===0?!0:r.length>0:!1}function es(r){return r!=null&&r.toString===String.prototype.toString}function ns(r){return Array.isArray(r)}function ss(r,t){Me(r)||Se("utils.sum() expects an array, received:",r);let e=0,n;for(let o=0,s=r.length;o<s;o++)n=r[o],n&&(e+=n);return e}function is(r,t,e){if(!Me(r))throw new Error(`#forEach() takes an array-like argument. ${r}`);for(let n=0,o=r.length;n<o;n++)t.call(e,r[n],n)}function os(r,t){for(let e=0,n=r.length;e<n;e++)r[e]=t;return r}function rs(r,t,e){const n=r.length-2,o=[];let s,i,c,l,h,u,a,f,d,m,g,b,w,S,v,O,R;for(ws(t,r),O=0;O<n;){for(s=r[O],i=r[O+1],h=t[s],u=t[i],d=e[s],m=e[i],R=O;R<n&&(R+=2,c=r[R],a=t[c],!(u<a));){if(g=e[c],l=r[R+1],f=t[l],b=e[l],d>=g){if(d>b&&m>g&&m>b)continue}else if(d<b&&m<g&&m<b)continue;s==c||s==l||i==c||i==l||(w=cs(h,d,u,m,a,g,f,b),w&&(S=[s,i],v=[c,l],o.push(ze(w,S,v,t,e)),w.length==4&&o.push(ze(w.slice(2),S,v,t,e))))}O+=2}return o}function cs(r,t,e,n,o,s,i,c){const l=as(r,t,e,n,o,s,i,c);let h=null;return l&&(h=hs(r,t,e,n,o,s,i,c),h?ps(r,t,e,n,o,s,i,c)&&(h=null):h=gs(r,t,e,n,o,s,i,c)),h}function as(r,t,e,n,o,s,i,c){return Kt(r,t,e,n,o,s)*Kt(r,t,e,n,i,c)<=0&&Kt(o,s,i,c,r,t)*Kt(o,s,i,c,e,n)<=0}function Kt(r,t,e,n,o,s){return cn(r-o,t-s,e-o,n-s)}function cn(r,t,e,n){return r*n-t*e}function hs(r,t,e,n,o,s,i,c){let l=ie(r,t,e,n,o,s,i,c),h;return l&&(h=fs(l[0],l[1],r,t,e,n,o,s,i,c),h==1?l=ie(e,n,r,t,o,s,i,c):h==2?l=ie(o,s,i,c,r,t,e,n):h==3&&(l=ie(i,c,o,s,r,t,e,n))),l&&ds(l,r,t,e,n,o,s,i,c),l}function ie(r,t,e,n,o,s,i,c){const l=cn(e-r,n-t,i-o,c-s),h=1e-18;let u;if(l===0)return null;const a=Kt(o,s,i,c,r,t)/l;return l<=h&&l>=-h?u=ls(r,t,e,n,o,s,i,c):u=[r+a*(e-r),t+a*(n-t)],u}function ls(r,t,e,n,o,s,i,c){let l=null;return!It(r,o,i)&&!It(t,s,c)?l=[r,t]:!It(e,o,i)&&!It(n,s,c)?l=[e,n]:!It(o,r,e)&&!It(s,t,n)?l=[o,s]:!It(i,r,e)&&!It(c,t,n)&&(l=[i,c]),l}function It(r,t,e){let n;return t<e?n=r<t||r>e:t>e?n=r>t||r<e:n=r!=t,n}function fs(r,t,...e){let n=-1,o=1/0,s;for(let i=0,c=0,l=e.length;c<l;i++,c+=2)s=us(r,t,e[c],e[c+1]),s<o&&(o=s,n=i);return n}function us(r,t,e,n){const o=r-e,s=t-n;return o*o+s*s}function ds(r,t,e,n,o,s,i,c,l){let h=r[0],u=r[1];h=oe(h,t,n),h=oe(h,s,c),u=oe(u,e,o),u=oe(u,i,l),r[0]=h,r[1]=u}function oe(r,t,e){let n;return It(r,t,e)&&(n=Math.abs(r-t)<Math.abs(r-e)?t:e,r=n),r}function gs(r,t,e,n,o,s,i,c){const l=Math.min(r,e,o,i),h=Math.max(r,e,o,i),u=Math.min(t,n,s,c),a=Math.max(t,n,s,c),f=a-u>h-l;let d=[];return(f?Pt(t,u,a):Pt(r,l,h))&&d.push(r,t),(f?Pt(n,u,a):Pt(e,l,h))&&d.push(e,n),(f?Pt(s,u,a):Pt(o,l,h))&&d.push(o,s),(f?Pt(c,u,a):Pt(i,l,h))&&d.push(i,c),(d.length!=2&&d.length!=4||d.length==4&&d[0]==d[2]&&d[1]==d[3])&&(d=null),d}function ps(r,t,e,n,o,s,i,c){return r==o&&t==s||r==i&&t==c||e==o&&n==s||e==i&&n==c}function Pt(r,t,e){return r>t&&r<e}function ws(r,t){ms(r,t),an(r,t,0,t.length-2)}function ms(r,t){for(let e=0,n=t.length;e<n;e+=2)r[t[e]]>r[t[e+1]]&&bs(t,e,e+1)}function bs(r,t,e){const n=r[t];r[t]=r[e],r[e]=n}function an(r,t,e,n){let o=e,s=n,i,c;for(;o<n;){for(i=r[t[e+n>>2<<1]];o<=s;){for(;r[t[o]]<i;)o+=2;for(;r[t[s]]>i;)s-=2;o<=s&&(c=t[o],t[o]=t[s],t[s]=c,c=t[o+1],t[o+1]=t[s+1],t[s+1]=c,o+=2,s-=2)}if(s-e<40?Le(r,t,e,s):an(r,t,e,s),n-o<40){Le(r,t,o,n);return}e=o,s=n}}function Le(r,t,e,n){let o,s;for(let i=e+2;i<=n;i+=2){o=t[i],s=t[i+1];let c;for(c=i-2;c>=e&&r[o]<r[t[c]];c-=2)t[c+2]=t[c],t[c+3]=t[c+1];t[c+2]=o,t[c+3]=s}}function ze(r,t,e,n,o){const s=r[0],i=r[1];t=Ve(s,i,t[0],t[1],n,o),e=Ve(s,i,e[0],e[1],n,o);const c=t[0]<e[0]?t:e,l=c==t?e:t;return{x:s,y:i,a:c,b:l}}function Ve(r,t,e,n,o,s){let i=e<n?e:n,c=i===e?n:e;return o[i]==r&&s[i]==t?c=i:o[c]==r&&s[c]==t&&(i=c),[i,c]}function hn(r){const t={};return r.filter(e=>{const n=ys(e);return n in t?!1:(t[n]=!0,!0)})}function ys(r){return`${r.a.join(",")};${r.b.join(",")}`}class _s{_i=0;_n=0;_inc=1;_xx;_yy;i=0;x=0;y=0;constructor(t,e){this._xx=t,this._yy=e}}function ks(r,t,e,n){let o=e|0;const s=isNaN(n)?r.length-o:n+o;let i,c,l,h,u,a;if(s>0)l=u=r[o],h=a=t[o];else return[void 0,void 0,void 0,void 0];for(o++;o<s;o++)i=r[o],c=t[o],i<l&&(l=i),i>u&&(u=i),c<h&&(h=c),c>a&&(a=c);return[l,h,u,a]}class he{xmin;ymin;xmax;ymax;constructor(...t){t.length>0&&this.setBounds(t)}cloneBounds(){return this.clone()}clone(){return new he(this.xmin,this.ymin,this.xmax,this.ymax)}width(){return this.xmax-this.xmin||0}height(){return this.ymax-this.ymin||0}setBounds(t,e,n,o){return arguments.length==1&&(Me(t)?(e=t[1],n=t[2],o=t[3],t=t[0]):(e=t.ymin,n=t.xmax,o=t.ymax,t=t.xmin)),this.xmin=t,this.ymin=e,this.xmax=n,this.ymax=o,(t>n||e>o)&&this.update(),this}update(){let t;this.xmin>this.xmax&&(t=this.xmin,this.xmin=this.xmax,this.xmax=t),this.ymin>this.ymax&&(t=this.ymin,this.ymin=this.ymax,this.ymax=t)}mergeBounds(t,...e){let n,o,s,i;return t instanceof he?(n=t.xmin,o=t.ymin,s=t.xmax,i=t.ymax):e.length==3?(n=t,o=e[0],s=e[1],i=e[2]):t.length==4?(n=t[0],o=t[1],s=t[2],i=t[3]):Se("Bounds#mergeBounds() invalid argument:",t),this.xmin===void 0?this.setBounds(n,o,s,i):(n<this.xmin&&(this.xmin=n),o<this.ymin&&(this.ymin=o),s>this.xmax&&(this.xmax=s),i>this.ymax&&(this.ymax=i)),this}}function le(r){const t=["a","b","c"].map(e=>r.properties[e].index);return[[0,1],[0,2],[1,2],[0,1,2]].map(e=>e.map(n=>t[n]).sort().join("-")).sort()}function Ae(r,t,e){const n=le(t.forw),o=le(t.bakw);if(JSON.stringify(n)!=JSON.stringify(o))throw`${JSON.stringify(t,null,2)}
${JSON.stringify(n)}
${JSON.stringify(o)}`;for(let s=0;s<n.length;s++){const i=n[s];r[i]||(r[i]=[]),r[i].push(t)}e&&(e.forw.features.push(t.forw),e.bakw.features.push(t.bakw))}function qe(r,t,e){const n=le(t.forw),o=le(t.bakw);if(JSON.stringify(n)!=JSON.stringify(o))throw`${JSON.stringify(t,null,2)}
${JSON.stringify(n)}
${JSON.stringify(o)}`;if(n.forEach(s=>{const i=r[s];if(!i)return;const c=i.filter(l=>l!==t);c.length===0?delete r[s]:r[s]=c}),e){const s=(i,c)=>{!i||!c||(i.features=i.features.filter(l=>l!==c))};s(e.forw,t.forw),s(e.bakw,t.bakw)}}function Qt(r,t,e){return ht.point(r,{target:{geom:t,index:e}})}function Gt(r){return ht.point(r.properties.target.geom,{target:{geom:r.geometry.coordinates,index:r.properties.target.index}})}function ke(r,t){const e=t.geometry.coordinates;return[0,1,2,3].map(n=>{const o=(n+1)%4,s=r[n],i=r[o],c=s.geometry.coordinates,l=Math.atan2(c[0]-e[0],c[1]-e[1]),h=[t,s,i,t].map(f=>f.geometry.coordinates),u={a:{geom:t.properties.target.geom,index:t.properties.target.index},b:{geom:s.properties.target.geom,index:s.properties.target.index},c:{geom:i.properties.target.geom,index:i.properties.target.index}},a=ht.featureCollection([ht.polygon([h],u)]);return[l,a]}).reduce((n,o)=>(n[0].push(o[0]),n[1].push(o[1]),n),[[],[]])}function xs(r){const{tins:t,targets:e,includeReciprocals:n}=r,o={};e.forEach(i=>{const c=t[i];if(!c||!c.features)return;o[i]={};const l={};c.features.forEach(h=>{const u=["a","b","c"];for(let a=0;a<3;a++){const f=(a+1)%3,d=u[a],m=u[f],g=h.properties[d].index,b=h.properties[m].index,w=[g,b].sort().join("-");if(l[w])continue;l[w]=!0;const S=h.geometry.coordinates[0][a],v=h.geometry.coordinates[0][f],O=h.properties[d].geom,R=h.properties[m].geom,N=Math.sqrt(Math.pow(O[0]-R[0],2)+Math.pow(O[1]-R[1],2))/Math.sqrt(Math.pow(S[0]-v[0],2)+Math.pow(S[1]-v[1],2)),U=o[i];U[`${g}:${w}`]=N,U[`${b}:${w}`]=N}})});const s={};return n&&(s.bakw={}),e.forEach(i=>{const c=o[i];if(s[i]={},!c)return;const l={};Object.keys(c).forEach(u=>{const[a]=u.split(":");l[a]||(l[a]=[]),l[a].push(c[u])}),Object.keys(l).forEach(u=>{const a=l[u],f=a.reduce((d,m)=>d+m,0)/a.length;s[i][u]=f,n&&s.bakw&&(s.bakw[u]=1/f)});let h=0;for(let u=0;u<4;u++){const a=`b${u}`,f=s[i][a]||0;h+=f}s[i].c=h/4,n&&s.bakw&&(s.bakw.c=1/s[i].c)}),s}function Ss(r,t){const e=r.split("-");if(e.length!==2||!e.every(s=>/^-?\d+$/.test(s)))return!1;const[n,o]=e.map(s=>parseInt(s,10)).sort((s,i)=>s-i);return t.some(s=>{if(s.length!==2)return!1;const i=s.map(l=>parseInt(`${l}`,10));if(i.some(l=>Number.isNaN(l)))return!1;const c=i.sort((l,h)=>l-h);return c[0]===n&&c[1]===o})}function Xe(r){return["a","b","c"].map((t,e)=>({prop:r.properties[t],geom:r.geometry.coordinates[0][e]}))}function Ms(r,t,e){let n=!1,o=!0;for(;o;){o=!1;const s=Object.keys(t);for(const i of s){const c=t[i];if(!c||c.length<2||Ss(i,e))continue;const l=i.split("-"),h=Xe(c[0].bakw),u=Xe(c[1].bakw),a=l.map(b=>h.find(w=>`${w.prop.index}`===b)||u.find(w=>`${w.prop.index}`===b));if(a.some(b=>!b))continue;const f=[h,u].map(b=>b.find(w=>!l.includes(`${w.prop.index}`)));if(f.some(b=>!b))continue;const d=c[0].bakw.geometry.coordinates[0].slice(0,3).map(b=>re(b)),m=c[1].bakw.geometry.coordinates[0].slice(0,3).map(b=>re(b));if(Ye(re(f[0].geom),m)||Ye(re(f[1].geom),d)){qe(t,c[0],r),qe(t,c[1],r),a.forEach(b=>{if(!b)return;const w=[b.geom,f[0].geom,f[1].geom,b.geom],S={a:b.prop,b:f[0].prop,c:f[1].prop},v=ht.polygon([w],S),O=Qe(v);Ae(t,{forw:O,bakw:v},r)}),n=!0,o=!0;break}}}return n}function re(r){return[r[0],r[1]]}function Ye(r,t){const[e,n]=t[0],[o,s]=t[1],[i,c]=t[2],l=i-e,h=c-n,u=o-e,a=s-n,f=r[0]-e,d=r[1]-n,m=l*l+h*h,g=l*u+h*a,b=l*f+h*d,w=u*u+a*a,S=u*f+a*d,v=m*w-g*g;if(v===0)return!1;const O=1/v,R=(w*b-g*S)*O,N=(m*S-g*b)*O,U=1e-9;return R>=-U&&N>=-U&&R+N<=1+U}const We=ae;class ct extends Tn{importance;priority;pointsSet;constructor(t={}){super(),t.bounds?this.setBounds(t.bounds):(this.setWh(t.wh),this.vertexMode=t.vertexMode||ct.VERTEX_PLAIN),this.strictMode=t.strictMode||ct.MODE_AUTO,this.yaxisMode=t.yaxisMode||ct.YAXIS_INVERT,this.importance=t.importance||0,this.priority=t.priority||0,this.stateFull=t.stateFull||!1,t.points&&this.setPoints(t.points),t.edges&&this.setEdges(t.edges)}getFormatVersion(){return We}setPoints(t){this.yaxisMode===ct.YAXIS_FOLLOW&&(t=t.map(e=>[e[0],[e[1][0],-1*e[1][1]]])),this.points=t,this.tins=void 0,this.indexedTins=void 0}setEdges(t=[]){this.edges=He(t),this.edgeNodes=void 0,this.tins=void 0,this.indexedTins=void 0}setBounds(t){this.bounds=t;let e=t[0][0],n=e,o=t[0][1],s=o;const i=[t[0]];for(let c=1;c<t.length;c++){const l=t[c];l[0]<e&&(e=l[0]),l[0]>n&&(n=l[0]),l[1]<o&&(o=l[1]),l[1]>s&&(s=l[1]),i.push(l)}i.push(t[0]),this.boundsPolygon=ht.polygon([i]),this.xy=[e,o],this.wh=[n-e,s-o],this.vertexMode=ct.VERTEX_PLAIN,this.tins=void 0,this.indexedTins=void 0}getCompiled(){const t={};t.version=We,t.points=this.points,t.weight_buffer=this.pointsWeightBuffer,t.centroid_point=[this.centroid.forw.geometry.coordinates,this.centroid.forw.properties.target.geom],t.vertices_params=[this.vertices_params.forw[0],this.vertices_params.bakw[0]],t.vertices_points=[];const e=this.vertices_params.forw[1];return e&&[0,1,2,3].map(n=>{const o=e[n].features[0],s=o.geometry.coordinates[0][1],i=o.properties.b.geom;t.vertices_points[n]=[s,i]}),t.strict_status=this.strict_status,t.tins_points=[[]],this.tins.forw.features.map(n=>{t.tins_points[0].push(["a","b","c"].map(o=>n.properties[o].index))}),this.strict_status===ct.STATUS_LOOSE?(t.tins_points[1]=[],this.tins.bakw.features.map(n=>{t.tins_points[1].push(["a","b","c"].map(o=>n.properties[o].index))})):this.strict_status===ct.STATUS_ERROR&&this.kinks?.bakw&&(t.kinks_points=this.kinks.bakw.features.map(n=>n.geometry.coordinates)),t.yaxisMode=this.yaxisMode,t.vertexMode=this.vertexMode,t.strictMode=this.strictMode,this.bounds?(t.bounds=this.bounds,t.boundsPolygon=this.boundsPolygon,t.xy=this.xy,t.wh=this.wh):t.wh=this.wh,t.edges=this.edges,t.edgeNodes=this.edgeNodes,t}setWh(t){this.wh=t||[100,100],this.xy=[0,0],this.bounds=void 0,this.boundsPolygon=void 0,this.tins=void 0,this.indexedTins=void 0}setVertexMode(t){this.vertexMode=t,this.tins=void 0,this.indexedTins=void 0}setStrictMode(t){this.strictMode=t,this.tins=void 0,this.indexedTins=void 0}calcurateStrictTin(){const t=this.tins.forw.features.map(o=>Qe(o));this.tins.bakw=ht.featureCollection(t);const e={};this.tins.forw.features.forEach((o,s)=>{const i=this.tins.bakw.features[s];Ae(e,{forw:o,bakw:i})}),Ms(this.tins,e,this.pointsSet?.edges||[]);const n=["forw","bakw"].map(o=>{const s=this.tins[o].features.map(i=>i.geometry.coordinates[0]);return rn(s)});n[0].length===0&&n[1].length===0?(this.strict_status=ct.STATUS_STRICT,delete this.kinks):(this.strict_status=ct.STATUS_ERROR,this.kinks={},n[0].length>0&&(this.kinks.forw=ht.featureCollection(n[0])),n[1].length>0&&(this.kinks.bakw=ht.featureCollection(n[1])))}generatePointsSet(){const t={forw:[],bakw:[]};for(let o=0;o<this.points.length;o++){const s=this.points[o][0],i=this.points[o][1],c=Qt(s,i,o);t.forw.push(c),t.bakw.push(Gt(c))}const e=[];let n=0;this.edgeNodes=[],this.edges||(this.edges=[]);for(let o=0;o<this.edges.length;o++){const s=this.edges[o][2],i=Object.assign([],this.edges[o][0]),c=Object.assign([],this.edges[o][1]);if(i.length===0&&c.length===0){e.push(s);continue}i.unshift(this.points[s[0]][0]),i.push(this.points[s[1]][0]),c.unshift(this.points[s[0]][1]),c.push(this.points[s[1]][1]);const l=[i,c].map(h=>{const u=h.map((f,d,m)=>{if(d===0)return 0;const g=m[d-1];return Math.sqrt(Math.pow(f[0]-g[0],2)+Math.pow(f[1]-g[1],2))}),a=u.reduce((f,d,m)=>m===0?[0]:(f.push(f[m-1]+d),f),[]);return a.map((f,d,m)=>{const g=f/m[m.length-1];return[h[d],u[d],a[d],g]})});l.map((h,u)=>{const a=l[u?0:1];return h.filter((f,d)=>!(d===0||d===h.length-1||f[4]==="handled")).map(f=>{const d=f[0],m=f[3],g=a.reduce((b,w,S,v)=>{if(b)return b;const O=v[S+1];if(w[3]===m)return w[4]="handled",[w];if(w[3]<m&&O&&O[3]>m)return[w,O]},void 0);if(g&&g.length===1)return u===0?[d,g[0][0],m]:[g[0][0],d,m];if(g&&g.length===2){const b=g[0],w=g[1],S=(m-b[3])/(w[3]-b[3]),v=[(w[0][0]-b[0][0])*S+b[0][0],(w[0][1]-b[0][1])*S+b[0][1]];return u===0?[d,v,m]:[v,d,m]}return[]})}).reduce((h,u)=>h.concat(u),[]).sort((h,u)=>h[2]<u[2]?-1:1).map((h,u,a)=>{this.edgeNodes[n]=[h[0],h[1]];const f=Qt(h[0],h[1],`e${n}`);n++,t.forw.push(f),t.bakw.push(Gt(f)),u===0?e.push([s[0],t.forw.length-1]):e.push([t.forw.length-2,t.forw.length-1]),u===a.length-1&&e.push([t.forw.length-1,s[1]])})}return{forw:t.forw,bakw:t.bakw,edges:e}}validateAndPrepareInputs(){const t=this.xy[0]-.05*this.wh[0],e=this.xy[0]+1.05*this.wh[0],n=this.xy[1]-.05*this.wh[1],o=this.xy[1]+1.05*this.wh[1];if(!this.points.reduce((c,l)=>c&&(this.bounds?ln(l[0],this.boundsPolygon):l[0][0]>=t&&l[0][0]<=e&&l[0][1]>=n&&l[0][1]<=o),!0))throw"SOME POINTS OUTSIDE";let i=[];return this.wh&&(i=[[t,n],[e,n],[t,o],[e,o]]),{pointsSet:this.generatePointsSet(),bbox:i,minx:t,maxx:e,miny:n,maxy:o}}updateTin(){let t=this.strictMode;t!==ct.MODE_STRICT&&t!==ct.MODE_LOOSE&&(t=ct.MODE_AUTO);const{pointsSet:e,bbox:n,minx:o,maxx:s,miny:i,maxy:c}=this.validateAndPrepareInputs(),l={forw:ht.featureCollection(e.forw),bakw:ht.featureCollection(e.bakw)},h=Jt(l.forw,e.edges,"target"),u=Jt(l.bakw,e.edges,"target");if(h.features.length===0||u.features.length===0)throw"TOO LINEAR1";const a=fn(l.forw),f=ve(l.forw);if(!f)throw"TOO LINEAR2";const d={},m=f.geometry.coordinates[0];let g;try{g=m.map(E=>({forw:E,bakw:ce(ht.point(E),h)})),g.forEach(E=>{d[`${E.forw[0]}:${E.forw[1]}`]=E})}catch{throw"TOO LINEAR2"}const b=ve(l.bakw);if(!b)throw"TOO LINEAR2";const w=b.geometry.coordinates[0];try{g=w.map(E=>({bakw:E,forw:ce(ht.point(E),u)})),g.forEach(E=>{d[`${E.forw[0]}:${E.forw[1]}`]=E})}catch{throw"TOO LINEAR2"}const S={forw:a.geometry.coordinates,bakw:ce(a,h)},v=Qt(S.forw,S.bakw,"c");this.centroid={forw:v,bakw:Gt(v)};const O={convexBuf:d,centroid:S,bbox:n,minx:o,maxx:s,miny:i,maxy:c},R=this.vertexMode===ct.VERTEX_BIRDEYE?Zn(O):Hn(O),N={forw:[],bakw:[]};for(let E=0;E<R.length;E++){const V=R[E].forw,L=R[E].bakw,z=Qt(V,L,`b${E}`),W=Gt(z);e.forw.push(z),e.bakw.push(W),N.forw.push(z),N.bakw.push(W)}this.pointsSet={forw:ht.featureCollection(e.forw),bakw:ht.featureCollection(e.bakw),edges:e.edges},this.tins={forw:Ce(Jt(this.pointsSet.forw,e.edges,"target"))},(t===ct.MODE_STRICT||t===ct.MODE_AUTO)&&this.calcurateStrictTin(),(t===ct.MODE_LOOSE||t===ct.MODE_AUTO&&this.strict_status===ct.STATUS_ERROR)&&(this.tins.bakw=Ce(Jt(this.pointsSet.bakw,e.edges,"target")),delete this.kinks,this.strict_status=ct.STATUS_LOOSE),this.vertices_params={forw:ke(N.forw,this.centroid.forw),bakw:ke(N.bakw,this.centroid.bakw)},this.addIndexedTin();const U=["forw"];this.strict_status===ct.STATUS_LOOSE&&U.push("bakw");const X=this.strict_status===ct.STATUS_STRICT;this.pointsWeightBuffer=xs({tins:this.tins,targets:U,includeReciprocals:X})}async updateTinAsync(){this.updateTin()}}exports.Tin=ct;exports.constrainedTin=Jt;exports.counterPoint=Gt;exports.createPoint=Qt;exports.findIntersections=rn;exports.format_version=ae;exports.insertSearchIndex=Ae;exports.vertexCalc=ke;
