# MaplatTin TIN 構築メモ

本メモは `Tin` 実装がどのように三角網を構成しているかを整理したものです。とくに分かりづらい境界補完ノード（`b0`〜`b3`）と `weight_buffer` の算出処理に注目しています。

## 更新フローの概要

1. `Tin.updateTin()` から `validateAndPrepareInputs()`（`src/tin.ts:471`）を呼び、全ての前面 GCP が処理対象領域に入っているかを検証します。明示的な境界が無ければ `wh` を基に 5 % だけ余裕を持たせた矩形を生成します。
2. `generatePointsSet()`（`src/tin.ts:303`）で各 GCP を GeoJSON Point に変換し、制約エッジを分割します。途中のノードには `e0`, `e1` といった ID が与えられ、後段の三角分割や重み計算に参加します。
3. `constrainedTin()` を使って前面・背面の制約付き三角網を生成します（`src/tin.ts:522`）。前面は常に必須で、背面は strict モードが維持できなかったときだけ再生成されます。
4. `convex()` で得た凸包を利用して重心点 `c` を設定し（`src/tin.ts:537`）、`calculatePlainVertices()` または `calculateBirdeyeVertices()` で 4 つの境界ノードを合成します。
5. 生成したノードを点群に追加し、TIN の検索用インデックスを整備した後、`calculatePointsWeight()` で補間用の `weight_buffer` を求めます。

## 境界ノード補完（`calculatePlainVertices`）

`Tin` では前面・背面の空間を共通の四角形で包むために、`b0`〜`b3` という仮想制御点を挿入します。その手順は次のとおりです。

1. **凸包サンプルの収集。** `convexBuf` は各凸包頂点（前面座標）と、その点を三角網で変換した背面座標のペアを保持します。前面・背面双方の凸包から取得することで極端な変形にも耐えるようにしています（`src/tin.ts:541`–`566`）。
2. **境界への射影。** 重心から凸包頂点へ伸ばしたベクトルを、前面・背面それぞれで追跡します。前面ベクトルが拡張矩形のどの辺にぶつかるかを `xRate`, `yRate` で判定し、符号に応じて上 (0) / 右 (1) / 下 (2) / 左 (3) のバケットに分類します（`src/tin.ts:700`–`738`）。
3. **象限ごとのスケール・回転推定。** 各バケット内で前面ベクトルと背面ベクトルの距離比と角度差を集計します。最小の距離比と平均角度差を計算し、`vertexRatio`（4 要素の `[scale, theta]` 配列）としてまとめます。サンプルが無い象限は別象限の値を流用します（`src/tin.ts:742`–`796`）。
4. **仮の頂点を配置。** 各 `bbox[i]` コーナーから重心への距離をスケール比で伸縮し、角度を `theta` だけ回転させることで背面座標を得ます。最後に頂点 2 と 3 を入れ替えて一貫した回転方向を保ちます（`src/tin.ts:807`–`823`）。
5. **エッジ交差の補正。** `checkAndAdjustVertices()` は重心と各エッジノードを結ぶ線分が背面の境界線を横切らないかを確認します。交差しそうな場合は該当する頂点の比率を広げ、線分が境界で止まるように調整します（`src/tin.ts:866`–`904`）。

こうして、すべての変換後ジオメトリを安全に包含しつつ、局所的な回転やアスペクト比も概ね維持した境界ノードが得られます。

## 重みバッファの平均化（`calculatePointsWeight`）

`weight_buffer` は、前面と背面で各制御点がどれだけ引き伸ばされるかを近似し、非線形の補間係数として利用されます。

1. **計算対象の決定。** 常に前面の三角網を評価し、`strict_status` が `STATUS_LOOSE` のときだけ背面も加えます（`src/tin.ts:918`–`924`）。
2. **エッジ比の取得。** 各三角形について未処理のエッジを一度ずつ取り出し、背面距離 ÷ 前面距離の比率を計算します。結果は端点ごとに `"<pointId>:<sortedEdgeId>"` というキーで保存されます（`src/tin.ts:930`–`962`）。
3. **点ごとの平均化。** 同じ点に属する比率を平均し、`pointsWeightBuffer[target][pointId]` として記録します。strict モードでは逆数を `pointsWeightBuffer.bakw` にも書き込み、逆変換時の補間を合わせます（`src/tin.ts:969`–`1006`）。
4. **重心の重み。** 重心 `c` はエッジを持たないため、周囲の `b0`〜`b3` の平均を採用します。strict モードでは再び逆数を背面テーブルへ保存します（`src/tin.ts:1008`–`1021`）。

エッジごとに一度だけ寄与するため、この平均値は各点が隣接点との間でどれだけ伸縮しているかを反映します。比率が大きい点ほど背面での距離が長く、補間時にその方向へウェイトを寄せるよう動作します。

## 補足事項

- strict モードは前面三角網を逆変換にも使おうとします。エッジ交差が検出されると `STATUS_ERROR` となり、背面三角網を再生成した上で両方向の `weight_buffer` を用意します。
- テストから呼ばれる `updateTinAsync()` は `updateTin()` を Promise でラップしているだけで、実際には非同期要素を持ちません。次のイテレーションで Promise/async の整理対象になる予定です。

これらの知見を踏まえることで、境界ノード計算や重み算出のドキュメント化・リファクタリング・非同期処理の簡素化を安心して進められます。
